<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <title>‚öîÔ∏è CANTON ARMY BATTLE</title>
    <link rel="icon" href="logo.ico" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.auth0.com/js/auth0-spa-js/2.1/auth0-spa-js.production.js"></script>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Orbitron', monospace;
    background: linear-gradient(135deg, #000000 0%, #0a0a0a 30%, #1a1a1a 60%, #0d0d0d 100%);
    color: white;
    overflow-x: hidden;
    position: relative;
    user-select: none;
}

.hero {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px;
    position: relative;
    overflow: hidden;
}

.hero::before {
    content: '';
    position: absolute;
    inset: 0;
    background: 
        radial-gradient(circle at 20% 50%, rgba(164, 184, 72, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 50%, rgba(196, 216, 111, 0.1) 0%, transparent 50%);
    pointer-events: none;
}

.hero-logo {
    width: 150px;
    height: 150px;
    margin-bottom: 30px;
    filter: drop-shadow(0 0 30px rgba(196, 216, 111, 0.8));
    animation: logoFloat 3s ease-in-out infinite;
}

@keyframes logoFloat {
    0%, 100% {
        transform: translateY(0) rotate(0deg);
        filter: drop-shadow(0 0 30px rgba(196, 216, 111, 0.8));
    }
    50% {
        transform: translateY(-20px) rotate(5deg);
        filter: drop-shadow(0 0 50px rgba(196, 216, 111, 1));
    }
}

.logo {
    font-size: clamp(2.5rem, 8vw, 5rem);
    font-weight: 900;
    margin-bottom: 20px;
    text-shadow: 0 0 20px rgba(196, 216, 111, 0.8), 0 0 40px rgba(196, 216, 111, 0.4);
    letter-spacing: 5px;
    animation: pulse 3s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.9; transform: scale(1.02); }
}

.tagline {
    font-size: clamp(1rem, 3vw, 1.5rem);
    color: #c4d86f;
    margin-bottom: 40px;
    letter-spacing: 3px;
    font-weight: 500;
}

.cta-button {
    background: linear-gradient(45deg, #a4b848, #c4d86f);
    color: #000;
    padding: 20px 50px;
    font-size: clamp(1.2rem, 3vw, 1.8rem);
    font-weight: 900;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 0 30px rgba(196, 216, 111, 0.5);
    text-transform: uppercase;
    letter-spacing: 2px;
    font-family: 'Orbitron', monospace;
}

.cta-button:hover {
    transform: scale(1.05);
    box-shadow: 0 0 50px rgba(196, 216, 111, 0.8);
}

.auth-buttons {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
}

.guest-button {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid #c4d86f;
    color: #c4d86f;
    padding: 18px 40px;
    font-size: clamp(1rem, 3vw, 1.4rem);
    font-weight: 700;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: 'Orbitron', monospace;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.guest-button:hover {
    background: rgba(196, 216, 111, 0.2);
    border-color: #ffab52;
    color: #ffab52;
    transform: scale(1.05);
    box-shadow: 0 0 30px rgba(196, 216, 111, 0.4);
}

.signin-button {
    background: linear-gradient(45deg, #1DA1F2, #0d8bd9);
    color: #fff;
    padding: 18px 40px;
    font-size: clamp(1rem, 3vw, 1.4rem);
    font-weight: 900;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 0 30px rgba(29, 161, 242, 0.5);
    text-transform: uppercase;
    letter-spacing: 2px;
    font-family: 'Orbitron', monospace;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.signin-button:hover {
    transform: scale(1.05);
    box-shadow: 0 0 50px rgba(29, 161, 242, 0.8);
    background: linear-gradient(45deg, #0d8bd9, #1DA1F2);
}

@media (max-width: 768px) {
  .node {
    position: relative;
  }
  
  .node::before {
    content: '';
    position: absolute;
    top: -15px;
    left: -15px;
    right: -15px;
    bottom: -15px;
    cursor: pointer;
  }
}

@media (max-width: 768px) {
    .auth-buttons {
        gap: 15px;
    }
    
    .guest-button, .signin-button {
        padding: 15px 30px;
        font-size: 1.1rem;
    }
}

@media (max-width: 480px) {
    .auth-buttons {
        flex-direction: column;
        width: 100%;
        gap: 12px;
    }
    
    .guest-button, .signin-button {
        width: 100%;
        padding: 12px 25px;
        font-size: 1rem;
    }
}

.hero-rules-btn {
    background: transparent;
    border: 2px solid rgba(196, 216, 111, 0.3);
    color: rgba(196, 216, 111, 0.7);
    padding: 12px 30px;
    font-size: clamp(0.85rem, 2.5vw, 1rem);
    font-weight: 600;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: 'Orbitron', monospace;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-top: 20px;
}

.hero-rules-btn:hover {
    background: rgba(196, 216, 111, 0.1);
    border-color: #c4d86f;
    color: #c4d86f;
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(196, 216, 111, 0.3);
}

@media (max-width: 768px) {
    .hero-rules-btn {
        padding: 10px 25px;
        font-size: 0.85rem;
        margin-top: 15px;
    }
}

@media (max-width: 480px) {
    .hero-rules-btn {
        width: 100%;
        padding: 10px 20px;
        font-size: 0.8rem;
        margin-top: 12px;
    }
}

.game-container {
    display: none;
    min-height: 100vh;
    padding: 20px;
    position: relative;
}

.game-container.active {
    display: block;
}

.top-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    flex-wrap: wrap;
    gap: 15px;
}

.game-title {
    font-size: clamp(1.5rem, 4vw, 2.5rem);
    font-weight: 900;
    text-shadow: 0 0 15px rgba(196, 216, 111, 0.8);
}

.control-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.control-btn, .leaderboard-btn {
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #c4d86f;
    color: #c4d86f;
    padding: 10px 20px;
    font-family: 'Orbitron', monospace;
    font-size: 1rem;
    cursor: pointer;
    border-radius: 10px;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 5px;
    font-weight: 700;
}

.control-btn:hover, .leaderboard-btn:hover {
    background: #c4d86f;
    color: #000;
    box-shadow: 0 0 20px rgba(196, 216, 111, 0.6);
}

.control-btn.muted {
    border-color: #666;
    color: #666;
}

.leaderboard-btn {
    border-color: #ffab52;
    color: #ffab52;
}

.leaderboard-btn:hover {
    background: #ffab52;
    color: #000;
    box-shadow: 0 0 20px rgba(255, 171, 82, 0.6);
}

.stats-bar {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.stat {
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #a4b848;
    border-radius: 10px;
    padding: 15px;
    text-align: center;
}

.stat-label {
    font-size: 0.9rem;
    color: #c4d86f;
    margin-bottom: 5px;
}

.stat-value {
    font-size: clamp(1.5rem, 3vw, 2rem);
    font-weight: 900;
    color: white;
}

.stat-value.time {
    color: #ffab52;
}

.stat-value.combo {
    background: linear-gradient(45deg, #c4d86f, #ffab52);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.health-container {
    margin-bottom: 20px;
}

.health-bar {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    justify-content: center;
}

.heart {
    font-size: 2rem;
    animation: heartbeat 1.5s ease-in-out infinite;
}

@keyframes heartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.game-canvas {
    width: 100%;
    max-width: 800px;
    height: 600px;
    margin: 0 auto;
    background: rgba(0, 0, 0, 0.95);
    border: 3px solid #c4d86f;
    border-radius: 20px;
    position: relative;
    overflow: hidden;
    box-shadow: 0 0 50px rgba(196, 216, 111, 0.3);
}

.privacy-container {
    position: absolute;
    top: 20px;
    left: 20px;
    right: 20px;
    z-index: 10;
}

.privacy-label {
    font-size: 0.9rem;
    color: #c4d86f;
    margin-bottom: 5px;
    display: flex;
    align-items: center;
    gap: 5px;
}

.privacy-bar-container {
    background: rgba(0, 0, 0, 0.8);
    border: 2px solid #a4b848;
    border-radius: 20px;
    height: 30px;
    overflow: hidden;
}

.privacy-bar {
    height: 100%;
    background: linear-gradient(90deg, #ff4444 0%, #ffab52 50%, #c4d86f 100%);
    transition: width 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 0.9rem;
}

.node {
    position: absolute;
    width: 30px;
    height: 40px;
    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    cursor: pointer;
    transition: transform 0.1s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 0 black;
    animation: bounce 2s ease-in-out infinite;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
}

.node img {
    width: 30px;
    height: 30px;
    object-fit: contain;
    pointer-events: none;
}

.node.poison img, .node.deadly-poison img {
    mix-blend-mode: screen;
    filter: invert(1) brightness(1.5);
}

.node.player {
    background: linear-gradient(45deg, #1e40af, #d2691e);
    box-shadow: 0 0 20px rgba(196, 216, 111, 0.8);
    z-index: 10;
    border: 3px solid #c4d86f;
    animation: fortressPulse 2s ease-in-out infinite;
    width: 50px;
    height: 50px;
    pointer-events: none;
}

.node.player img {
    width: 40px;
    height: 40px;
}

@keyframes fortressPulse {
    0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 20px rgba(196, 216, 111, 0.8);
    }
    50% {
        transform: scale(1.08);
        box-shadow: 0 0 30px rgba(196, 216, 111, 1);
    }
}

.node.enemy {
    background: linear-gradient(45deg, #2f1b14, #5d4037);
    box-shadow: 0 0 8px rgba(95, 64, 55, 0.5);
}

.node.super {
    background: linear-gradient(45deg, #c4d86f, #ffab52);
    box-shadow: 0 0 15px rgba(196, 216, 111, 0.8);
    animation: superPulse 0.6s ease-in-out infinite;
}

.node.poison {
    background: linear-gradient(45deg, #4b0082, #8b008b);
    box-shadow: 0 0 15px rgba(139, 0, 139, 0.8);
    animation: poisonPulse 0.8s ease-in-out infinite;
    border: 2px solid #00ff00;
}

.node.deadly-poison {
    background: linear-gradient(45deg, #8b0000, #ff0000);
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.9);
    animation: deadlyPulse 0.7s ease-in-out infinite;
    border: 3px solid #ff0000;
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
}

@keyframes superPulse {
    0%, 100% { transform: scale(1) rotate(0deg); }
    50% { transform: scale(1.15) rotate(180deg); }
}

@keyframes poisonPulse {
    0%, 100% { 
        transform: scale(1);
        box-shadow: 0 0 15px rgba(139, 0, 139, 0.8);
    }
    50% { 
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.9);
    }
}

@keyframes deadlyPulse {
    0%, 100% { 
        transform: scale(1);
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.9);
    }
    50% { 
        transform: scale(1.15);
        box-shadow: 0 0 28px rgba(255, 0, 0, 1);
    }
}

.combo-display {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 4rem;
    font-weight: 900;
    color: #c4d86f;
    text-shadow: 3px 3px 0 black;
    pointer-events: none;
    opacity: 0;
    animation: comboFlash 1s ease;
}

@keyframes comboFlash {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
}

.health-damage, .miss-penalty, .poison-warning {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 3rem;
    font-weight: 900;
    color: #ff0000;
    text-shadow: 3px 3px 0 black;
    pointer-events: none;
    opacity: 0;
    animation: damageFlash 1.5s ease;
    z-index: 100;
}

@keyframes damageFlash {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
}

.modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.95);
    z-index: 1100;
    overflow-y: auto;
    padding: 40px 20px 20px;
    align-items: flex-start;
}

.modal.active {
    display: flex;
}

.modal-content {
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
    border: 3px solid #c4d86f;
    border-radius: 20px;
    padding: 40px;
    max-width: 600px;
    width: 100%;
    box-shadow: 0 0 40px rgba(196, 216, 111, 0.4);
    margin: 0 auto;
    max-height: calc(100vh - 80px);
    overflow-y: auto;
}

.modal-title {
    font-size: 2rem;
    font-weight: 900;
    text-align: center;
    margin-bottom: 30px;
    color: #c4d86f;
    text-shadow: 0 0 15px rgba(196, 216, 111, 0.8);
}

.rule-item {
    margin-bottom: 20px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.5);
    border-left: 4px solid #c4d86f;
    border-radius: 10px;
}

.rule-title {
    font-weight: 700;
    color: #c4d86f;
    margin-bottom: 5px;
}

.rule-desc {
    color: #ddd;
    font-size: 0.9rem;
    line-height: 1.4;
}

.close-btn {
    background: linear-gradient(45deg, #a4b848, #c4d86f);
    color: #000;
    padding: 15px 40px;
    font-size: 1.2rem;
    font-weight: 900;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    display: block;
    margin: 30px auto 0;
    transition: all 0.3s ease;
    font-family: 'Orbitron', monospace;
}

.close-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 25px rgba(196, 216, 111, 0.5);
}

.gameover-modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.98);
    z-index: 1000;
    align-items: center;
    justify-content: center;
}

.gameover-modal.active {
    display: flex;
}

.gameover-content {
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
    border: 3px solid #ff4444;
    border-radius: 20px;
    padding: 40px;
    max-width: 500px;
    width: 90%;
    text-align: center;
    box-shadow: 0 0 40px rgba(255, 68, 68, 0.4);
    animation: gameoverAppear 0.5s ease-out;
}

@keyframes gameoverAppear {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

.gameover-title {
    font-size: 3rem;
    font-weight: 900;
    color: #ff4444;
    margin-bottom: 20px;
    text-shadow: 0 0 20px rgba(255, 68, 68, 0.8);
}

.final-stats {
    margin: 30px 0;
}

.final-stat {
    display: flex;
    justify-content: space-between;
    padding: 10px 20px;
    margin-bottom: 10px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 10px;
    font-size: 1.1rem;
}

.final-stat-label {
    color: #c4d86f;
}

.final-stat-value {
    font-weight: 900;
}

.gameover-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
}

.retry-btn, .share-btn {
    padding: 15px 35px;
    font-size: 1.2rem;
    font-weight: 900;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    transition: all 0.3s ease;
}

.retry-btn {
    background: linear-gradient(45deg, #a4b848, #c4d86f);
    color: #000;
}

.share-btn {
    background: rgba(29, 161, 242, 0.9);
    color: white;
}

.retry-btn:hover, .share-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 25px currentColor;
}

.leaderboard-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.7);
    z-index: 1999;
}

.leaderboard-overlay.active {
    display: block;
}

.leaderboard-panel {
    position: fixed;
    top: 0;
    right: -100%;
    width: 100%;
    max-width: 450px;
    height: 100vh;
    background: linear-gradient(135deg, #000000 0%, #0a0a0a 30%, #1a1a1a 60%, #0d0d0d 100%);
    border-left: 3px solid #ffab52;
    z-index: 10000;
    overflow-y: auto;
    transition: right 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    box-shadow: -10px 0 40px rgba(0, 0, 0, 0.7);
}

.leaderboard-panel.active {
    right: 0;
}

.leaderboard-header {
    padding: 30px;
    background: rgba(0, 0, 0, 0.8);
    border-bottom: 2px solid #ffab52;
    position: sticky;
    top: 0;
    z-index: 10;
}

.leaderboard-title {
    font-size: 2rem;
    font-weight: 900;
    color: #ffab52;
    text-shadow: 0 0 15px rgba(255, 171, 82, 0.8);
    margin-bottom: 10px;
}

.leaderboard-subtitle {
    color: #c4d86f;
    font-size: 0.9rem;
}

.leaderboard-close {
    position: absolute;
    top: 20px;
    right: 20px;
    background: transparent;
    border: 2px solid #ff4444;
    color: #ff4444;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 1.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.leaderboard-close:hover {
    background: #ff4444;
    color: #000;
    transform: rotate(90deg);
}

.leaderboard-list {
    padding: 20px 30px 30px;
}

.leaderboard-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 15px;
    margin-bottom: 10px;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid #a4b848;
    border-radius: 10px;
    transition: all 0.3s ease;
}

.leaderboard-item:hover {
    background: rgba(196, 216, 111, 0.1);
    border-color: #c4d86f;
    transform: translateX(-5px);
    box-shadow: 0 0 15px rgba(196, 216, 111, 0.2);
}

.leaderboard-rank {
    font-size: 1.5rem;
    font-weight: 900;
    color: #ffab52;
    min-width: 40px;
    text-align: center;
}

.leaderboard-item:nth-child(1) .leaderboard-rank {
    color: #FFD700;
    text-shadow: 0 0 10px #FFD700;
}

.leaderboard-item:nth-child(2) .leaderboard-rank {
    color: #C0C0C0;
    text-shadow: 0 0 10px #C0C0C0;
}

.leaderboard-item:nth-child(3) .leaderboard-rank {
    color: #CD7F32;
    text-shadow: 0 0 10px #CD7F32;
}

.leaderboard-player {
    flex: 1;
}

.leaderboard-player-name {
    font-weight: 700;
    color: #fff;
    font-size: 1.1rem;
}

.leaderboard-score {
    font-size: 1.5rem;
    font-weight: 900;
    color: #c4d86f;
    text-shadow: 0 0 8px rgba(196, 216, 111, 0.4);
}

.leaderboard-empty {
    text-align: center;
    padding: 60px 20px;
    color: #888;
}

@media (max-width: 1024px) {
    .hero-logo {
        width: 120px;
        height: 120px;
    }
    .logo {
        font-size: 3rem;
    }
    .game-canvas {
        max-width: 700px;
        height: 500px;
    }
    .node {
        width: 26px;
        height: 34px;
        font-size: 16px;
    }
    .node img {
        width: 26px;
        height: 26px;
    }
    .node.player {
        width: 40px;
        height: 40px;
    }
    .node.player img {
        width: 32px;
        height: 32px;
    }
}

@media (max-width: 768px) {
    body {
        padding: 10px;
    }
    .hero {
        padding: 15px;
    }
    .hero-logo {
        width: 100px;
        height: 100px;
        margin-bottom: 20px;
        animation: none;
    }
    .logo {
        font-size: 2.2rem;
        letter-spacing: 3px;
    }
    .tagline {
        font-size: 0.9rem;
        margin-bottom: 30px;
    }
    .cta-button {
        padding: 15px 35px;
        font-size: 1.2rem;
    }
    .game-container {
        padding: 10px;
    }
    .top-bar {
        margin-bottom: 10px;
        gap: 8px;
    }
    .game-title {
        font-size: 1.3rem;
        width: 100%;
        text-align: center;
    }
    .control-buttons {
        width: 100%;
        justify-content: center;
    }
    .control-btn, .leaderboard-btn {
        padding: 8px 12px;
        font-size: 0.85rem;
        flex: 1;
        min-width: 80px;
    }
    .stats-bar {
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-bottom: 10px;
    }
    .stat {
        padding: 10px 8px;
    }
    .stat-label {
        font-size: 0.75rem;
        margin-bottom: 3px;
    }
    .stat-value {
        font-size: 1.3rem;
    }
    .health-container {
        margin-bottom: 10px;
    }
    .heart {
        font-size: 1.4rem;
        animation: none;
    }
    .game-canvas {
        max-width: 100%;
        width: 100%;
        height: calc(100vh - 420px);
        min-height: 400px;
        max-height: 500px;
        box-shadow: 0 0 20px rgba(196, 216, 111, 0.2);
    }
    .privacy-container {
        top: 15px;
        left: 15px;
        right: 15px;
    }
    .privacy-label {
        font-size: 0.75rem;
        margin-bottom: 3px;
    }
    .privacy-bar-container {
        height: 24px;
    }
    .privacy-bar {
        font-size: 0.75rem;
    }
    .node {
        width: 24px;
        height: 32px;
        font-size: 14px;
        animation: none;
    }
    .node img {
        width: 22px;
        height: 22px;
    }
    .node.player {
        width: 36px;
        height: 36px;
    }
    .node.player img {
        width: 30px;
        height: 30px;
    }
    .node.super {
        animation: superPulse 0.8s ease-in-out infinite;
    }
    .node.poison {
        animation: poisonPulse 1s ease-in-out infinite;
    }
    .node.deadly-poison {
        animation: deadlyPulse 0.9s ease-in-out infinite;
    }
    .node.poison img {
        width: 20px !important;
        height: 20px !important;
    }
    .node.deadly-poison img {
        width: 18px !important;
        height: 18px !important;
    }
    .combo-display {
        font-size: 2.5rem;
    }
    .health-damage, .miss-penalty, .poison-warning {
        font-size: 2rem;
    }
    .modal {
        padding: 15px;
        padding-top: 30px;
    }
    .modal-content {
        padding: 25px 20px;
        max-width: 95%;
        max-height: calc(100vh - 60px);
    }
    .modal-title {
        font-size: 1.5rem;
        margin-bottom: 20px;
    }
    .rule-item {
        padding: 12px;
        margin-bottom: 12px;
    }
    .rule-title {
        font-size: 0.9rem;
    }
    .rule-desc {
        font-size: 0.8rem;
    }
    .close-btn {
        padding: 12px 30px;
        font-size: 1rem;
    }
    .gameover-content {
        padding: 25px 20px;
        max-width: 90%;
    }
    .gameover-title {
        font-size: 2rem;
        margin-bottom: 15px;
    }
    .final-stats {
        margin: 20px 0;
    }
    .final-stat {
        padding: 8px 15px;
        margin-bottom: 8px;
        font-size: 0.95rem;
    }
    .retry-btn, .share-btn {
        padding: 12px 25px;
        font-size: 1rem;
    }
    .leaderboard-panel {
        max-width: 100%;
    }
    .leaderboard-header {
        padding: 20px 15px;
    }
    .leaderboard-title {
        font-size: 1.4rem;
    }
    .leaderboard-subtitle {
        font-size: 0.8rem;
    }
    .leaderboard-list {
        padding: 15px;
    }
    .leaderboard-item {
        padding: 10px;
        gap: 8px;
    }
    .leaderboard-rank {
        font-size: 1.1rem;
        min-width: 30px;
    }
    .leaderboard-player-name {
        font-size: 0.85rem;
        word-break: break-word;
    }
    .leaderboard-score {
        font-size: 1.1rem;
    }
}

@media (max-width: 480px) {
    .stats-bar {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
    }
    .stat {
        padding: 8px 6px;
    }
    .stat-label {
        font-size: 0.7rem;
    }
    .stat-value {
        font-size: 1.1rem;
    }
    .heart {
        font-size: 1.2rem;
    }
    .game-canvas {
        height: calc(100vh - 400px);
        min-height: 350px;
        max-height: 450px;
        border-width: 2px;
    }
    .privacy-container {
        top: 10px;
        left: 10px;
        right: 10px;
    }
    .privacy-label {
        font-size: 0.65rem;
    }
    .privacy-bar-container {
        height: 20px;
    }
    .privacy-bar {
        font-size: 0.65rem;
    }
    .node {
        width: 20px;
        height: 28px;
        font-size: 12px;
    }
    .node img {
        width: 18px;
        height: 18px;
    }
    .node.player {
        width: 32px;
        height: 32px;
    }
    .node.player img {
        width: 26px;
        height: 26px;
    }
    .node.poison img {
        width: 16px !important;
        height: 16px !important;
    }
    
    .node.deadly-poison img {
        width: 14px !important;
        height: 14px !important;
    }
    .combo-display {
        font-size: 2rem;
    }
    .health-damage, .miss-penalty, .poison-warning {
        font-size: 1.5rem;
    }
    .game-title {
        font-size: 1.1rem;
    }
    .control-btn, .leaderboard-btn {
        padding: 10px;
        font-size: 1.5rem;
        min-width: 44px;
        width: 44px;
        height: 44px;
        justify-content: center;
        flex: 0 0 auto;
    }
    .btn-text {
        display: none;
    }
    .btn-icon {
        font-size: 1.5rem;
    }
    .modal-title {
        font-size: 1.3rem;
    }
    .rule-item {
        padding: 10px;
        margin-bottom: 10px;
    }
    .rule-title {
        font-size: 0.85rem;
    }
    .rule-desc {
        font-size: 0.75rem;
    }
    .gameover-title {
        font-size: 1.6rem;
    }
    .final-stat {
        padding: 6px 12px;
        font-size: 0.85rem;
    }
    .retry-btn, .share-btn {
        padding: 10px 20px;
        font-size: 0.9rem;
    }
    .hero-logo {
        width: 80px;
        height: 80px;
    }
    .logo {
        font-size: 1.8rem;
    }
    .tagline {
        font-size: 0.8rem;
    }
    .cta-button {
        padding: 12px 28px;
        font-size: 1rem;
    }
    .leaderboard-header {
        padding: 15px 12px;
    }
    .leaderboard-title {
        font-size: 1.2rem;
    }
    .leaderboard-subtitle {
        font-size: 0.7rem;
    }
    .leaderboard-list {
        padding: 12px;
    }
    .leaderboard-item {
        padding: 8px;
        gap: 6px;
    }
    .leaderboard-rank {
        font-size: 1rem;
        min-width: 28px;
    }
    .leaderboard-player-name {
        font-size: 0.75rem;
    }
    .leaderboard-score {
        font-size: 1rem;
    }
    .leaderboard-close {
        width: 35px;
        height: 35px;
        font-size: 1.3rem;
        top: 15px;
        right: 15px;
    }
}

@media (max-width: 375px) {
    .stats-bar {
        gap: 5px;
    }
    .stat {
        padding: 6px 4px;
    }
    .stat-value {
        font-size: 1rem;
    }
    .game-canvas {
        height: calc(100vh - 380px);
        min-height: 320px;
    }
    .node {
        width: 18px;
        height: 26px;
        font-size: 11px;
    }
    .node img {
        width: 16px;
        height: 16px;
    }
    .node.player {
        width: 28px;
        height: 28px;
    }
    .node.player img {
        width: 24px;
        height: 24px;
    }
    .heart {
        font-size: 1rem;
    }
}

@media (max-height: 500px) and (orientation: landscape) {
    .game-canvas {
        height: calc(100vh - 200px);
        min-height: 250px;
        max-height: 350px;
    }
    .stats-bar {
        grid-template-columns: repeat(5, 1fr);
        gap: 5px;
    }
    .stat {
        padding: 5px;
    }
    .stat-label {
        font-size: 0.65rem;
    }
    .stat-value {
        font-size: 0.9rem;
    }
    .health-container {
        margin-bottom: 5px;
    }
    .heart {
        font-size: 1rem;
    }
    .top-bar {
        margin-bottom: 5px;
    }
}

.leaderboard-tabs {
    display: flex;
    gap: 10px;
    padding: 0 30px 20px;
    border-bottom: 2px solid rgba(196, 216, 111, 0.3);
}

.leaderboard-tab {
    flex: 1;
    padding: 12px 20px;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid #a4b848;
    border-radius: 10px;
    color: #c4d86f;
    font-family: 'Orbitron', monospace;
    font-weight: 700;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.leaderboard-tab:hover {
    background: rgba(196, 216, 111, 0.1);
    border-color: #c4d86f;
    transform: translateY(-2px);
}

.leaderboard-tab.active {
    background: linear-gradient(45deg, #a4b848, #c4d86f);
    color: #000;
    border-color: #ffab52;
    box-shadow: 0 0 20px rgba(196, 216, 111, 0.6);
}

.weekly-reset-timer {
    text-align: center;
    padding: 15px 30px;
    color: #ffab52;
    font-size: 0.85rem;
    border-bottom: 1px solid rgba(255, 171, 82, 0.2);
    font-weight: 600;
}

.weekly-crown {
    display: inline-block;
    margin-left: 8px;
    font-size: 1.2rem;
    animation: crownFloat 2s ease-in-out infinite;
}

@keyframes crownFloat {
    0%, 100% { transform: translateY(0px) rotate(-5deg); }
    50% { transform: translateY(-3px) rotate(5deg); }
}

.leaderboard-item.weekly-top {
    border-color: #ff6b35;
    box-shadow: 0 0 20px rgba(255, 107, 53, 0.4);
}

.leaderboard-item.weekly-top:hover {
    box-shadow: 0 0 30px rgba(255, 107, 53, 0.6);
}

@media (max-width: 768px) {
    .leaderboard-tabs {
        padding: 0 15px 15px;
    }
    
    .leaderboard-tab {
        padding: 10px 15px;
        font-size: 0.8rem;
    }
    
    .weekly-reset-timer {
        padding: 12px 15px;
        font-size: 0.75rem;
    }
}
.load-more-btn {
  width: 100%;
  padding: 15px;
  margin-top: 15px;
  background: rgba(196, 216, 111, 0.1);
  border: 2px solid #a4b848;
  border-radius: 10px;
  color: #c4d86f;
  font-family: Orbitron, monospace;
  font-size: 1rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.load-more-btn:hover {
  background: rgba(196, 216, 111, 0.2);
  border-color: #c4d86f;
  transform: translateY(-2px);
  box-shadow: 0 0 20px rgba(196, 216, 111, 0.3);
}

.load-more-btn:active {
  transform: translateY(0);
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}

.promo-modal {
    display: flex;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.95);
    z-index: 9999;
    align-items: center;
    justify-content: center;
    animation: promoSlideIn 0.5s ease-out;
}

.promo-modal .promo-content {
    background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
    border: 3px solid #c4d86f;
    border-radius: 25px;
    padding: 30px;
    max-width: 450px;
    width: 90%;
    text-align: center;
    box-shadow: 0 0 50px rgba(196, 216, 111, 0.6);
    position: relative;
}

.promo-header {
    margin-bottom: 25px;
}

.promo-crown {
    font-size: 2.5rem;
    margin-bottom: 10px;
    animation: crownFloat 2s ease-in-out infinite;
}

.promo-header h2 {
    font-size: 1.8rem;
    font-weight: 900;
    background: linear-gradient(45deg, #FFD700, #c4d86f);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    margin: 0;
}

.reward-tier {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
    padding: 15px;
    background: rgba(196, 216, 111, 0.1);
    border-radius: 15px;
    border-left: 4px solid #c4d86f;
}

.rank {
    font-size: 1.5rem;
    font-weight: 900;
    color: #FFD700;
    min-width: 40px;
}

.prize {
    font-size: 1.3rem;
    font-weight: 900;
    color: #c4d86f;
    text-shadow: 0 0 10px rgba(196, 216, 111, 0.8);
}

.current-rank {
    margin: 20px 0;
    padding: 15px;
    background: rgba(0,0,0,0.5);
    border-radius: 10px;
    border: 2px solid #ffab52;
}

.current-rank strong {
    color: #ffab52;
    font-size: 1.5rem;
}

.play-now-btn {
    background: linear-gradient(45deg, #c4d86f, #a4b848);
    color: #000;
    padding: 18px 40px;
    font-size: 1.2rem;
    font-weight: 900;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    width: 100%;
    margin-bottom: 10px;
    font-family: 'Orbitron', monospace;
    box-shadow: 0 0 30px rgba(196, 216, 111, 0.6);
    transition: all 0.3s ease;
}

.play-now-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 40px rgba(196, 216, 111, 0.9);
}

.close-promo-btn {
    background: transparent;
    border: 2px solid #ff4444;
    color: #ff4444;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 1.5rem;
    cursor: pointer;
    position: absolute;
    top: 15px;
    right: 15px;
    transition: all 0.3s ease;
}

.close-promo-btn:hover {
    background: #ff4444;
    color: #000;
    transform: rotate(90deg);
}

@keyframes promoSlideIn {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

@keyframes crownFloat {
    0%, 100% { transform: translateY(0px) rotate(-5deg); }
    50% { transform: translateY(-5px) rotate(5deg); }
}

@media (max-width: 480px) {
    .promo-modal .promo-content {
        padding: 20px;
        margin: 20px;
    }
    
    .promo-header h2 {
        font-size: 1.4rem;
    }
    
    .reward-tier {
        padding: 12px;
        gap: 10px;
    }
    
    .rank {
        font-size: 1.2rem;
    }
}

.gameover-buttons {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.gameover-secondary-buttons {
  display: flex;
  gap: 10px;
}

.icon-btn {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 2px solid #c4d86f;
  background: rgba(0,0,0,0.8);
  color: #c4d86f;
  font-size: 1.4rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  box-shadow: 0 0 12px rgba(196,216,111,0.4);
}

.icon-btn:hover {
  background: #c4d86f;
  color: #000;
  transform: translateY(-2px);
  box-shadow: 0 0 18px rgba(196,216,111,0.8);
}

@media (max-width: 480px) {
  .icon-btn {
    width: 38px;
    height: 38px;
    font-size: 1.2rem;
  }
}

.event-button {
    background: linear-gradient(45deg, #FFD700, #FFAB52);
    color: #000;
    padding: 20px 50px;
    font-size: clamp(1.1rem, 3vw, 1.6rem);
    font-weight: 900;
    border: 2px solid #FFEA70;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: Orbitron, monospace;
    text-transform: uppercase;
    letter-spacing: 2px;
    box-shadow: 0 0 35px rgba(255, 215, 0, 0.9);
    position: relative;
    overflow: hidden;
}

.event-button::before {
    content: "";
    position: absolute;
    top: 0;
    left: -150%;
    width: 130%;
    height: 100%;
    background: linear-gradient(
        120deg,
        transparent,
        rgba(255, 255, 255, 0.6),
        transparent
    );
    transform: skewX(-20deg);
    transition: all 0.5s ease;
}

.event-button:hover::before {
    left: 150%;
}

.event-button:hover {
    transform: scale(1.07);
    box-shadow: 0 0 50px rgba(255, 215, 0, 1);
}

.wallet-connect-btn {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.85);
  border: 2px solid #c4d86f;
  color: #c4d86f;
  padding: 8px 18px;
  font-family: 'Orbitron', monospace;
  font-size: 0.8rem;
  font-weight: 600;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  z-index: 9999;
  display: flex;
  align-items: center;
  gap: 6px;
}

.wallet-connect-btn:hover {
  background: rgba(196, 216, 111, 0.15);
}

.wallet-connect-btn.connected {
  border-color: #4ade80;
  color: #4ade80;
}

.wallet-dropdown {
  position: fixed;
  top: 52px;
  right: 20px;
  background: rgba(0, 0, 0, 0.95);
  border: 2px solid #c4d86f;
  border-radius: 8px;
  padding: 6px 0;
  z-index: 10000;
  min-width: 180px;
  display: none;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
}

.wallet-dropdown.active {
  display: block;
}

.wallet-dropdown-item {
  padding: 10px 14px;
  color: #ff4444;
  font-family: 'Orbitron', monospace;
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
  text-align: center;
  border-radius: 4px;
  transition: background 0.15s ease, border-color 0.15s ease;
  border: 1px solid transparent;
}

.wallet-dropdown-item:hover {
  background: rgba(255, 68, 68, 0.18);
  border-color: #ff4444;
}

@media (max-width: 768px) {
  .wallet-connect-btn {
    top: 10px;
    right: 10px;
    padding: 6px 14px;
    font-size: 0.75rem;
  }
  .wallet-dropdown {
    top: 44px;
    right: 10px;
  }
}

#signMessageBtn {
  transition: all 0.2s ease;
}

#signMessageBtn:hover {
  background: rgba(196, 216, 111, 0.15);
}

@media (max-width: 768px) {
  #signMessageBtn {
    top: 54px !important;
    padding: 6px 14px;
    font-size: 0.75rem;
  }
}

</style>

</head>
<body>

<div class="hero" id="hero">
    <img src="cn-favicon-05 1-1.webp" alt="Canton Logo" class="hero-logo">
    <div class="logo">‚öîÔ∏è CANTON ARMY BATTLE</div>
    <div class="tagline">COMMUNITY-POWERED MOVEMENT</div>

    <button class="wallet-connect-btn" id="consoleWalletBtn" onclick="handleConsoleWallet()">
    <img src="console.png" alt="Console Wallet" style="width: 20px; height: 20px; object-fit: contain; border-radius: 6px;">
    <span id="walletBtnText">Connect Console Wallet</span>
    </button>

    <div class="wallet-dropdown" id="walletDropdown">
        <div class="wallet-dropdown-item" onclick="disconnectWallet()">
            üîå Disconnect wallet
        </div>
    </div>

    <button class="wallet-connect-btn" id="signMessageBtn" onclick="signBattleMessage()" style="top: 62px; display: none;">
        <span>‚úÖ</span>
        <span id="signBtnText">Verify Wallet</span>
    </button>
    
    <div class="auth-buttons">
        <button class="guest-button" onclick="startGameAsGuest()">
            üéÆ PLAY AS GUEST
        </button>
        <button class="event-button" id="cantonEventButton" onclick="startCantonEvent()">
            CANTON NETWORK EVENT
        </button>
        <button class="signin-button" onclick="signInWithX()">
            <span style="font-size: 1.2rem;">ùïè</span> SIGN IN WITH X
        </button>
    </div>
    <button class="hero-rules-btn" onclick="toggleLeaderboard()">üèÜ VIEW LEADERBOARD</button>
    <button class="hero-rules-btn" onclick="showRules()">
        üìñ READ RULES
    </button>
</div>

    <div class="game-container" id="gameContainer">
        <div class="top-bar">
            <div class="game-title">‚öîÔ∏è CANTON ARMY BATTLE</div>
            <div class="control-buttons">
                <button class="control-btn" id="pause-btn" onclick="togglePause()" title="Pause">
                    <span class="btn-icon">‚è∏Ô∏è</span>
                    <span class="btn-text" id="pauseText">PAUSE</span>
                </button>
                <button class="control-btn" id="sound-btn" onclick="toggleSound()" title="Sound">
                    <span class="btn-icon">üîä</span>
                    <span class="btn-text" id="soundText">SOUND</span>
                </button>
                <button class="control-btn" onclick="showRules()" title="Rules">
                    <span class="btn-icon">üìã</span>
                    <span class="btn-text">RULES</span>
                </button>
                <button class="leaderboard-btn" onclick="toggleLeaderboard()" title="Leaderboard">
                    <span class="btn-icon">üèÜ</span>
                    <span class="btn-text">LEADERBOARD</span>
                </button>
            </div>
        </div>

        <div class="stats-bar">
            <div class="stat">
                <div class="stat-label">SCORE</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">COMBO</div>
                <div class="stat-value combo" id="combo">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">LEVEL</div>
                <div class="stat-value" id="level">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">TIME</div>
                <div class="stat-value time"><span id="time">30</span>s</div>
            </div>
            <div class="stat">
                <div class="stat-label">MISSED</div>
                <div class="stat-value" id="missed">0</div>
            </div>
        </div>

        <div class="health-container">
            <div class="stat-label" style="text-align: center; margin-bottom: 10px;">HEALTH</div>
            <div class="health-bar" id="healthBar"></div>
        </div>

        <div class="game-canvas" id="arena">
            <div class="privacy-container">
                <div class="privacy-label">‚öîÔ∏è PRIVACY SHIELD</div>
                <div class="privacy-bar-container">
                    <div class="privacy-bar" id="privacyLevel" style="width: 100%;">
                        <span id="privacyText">100%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="rulesModal">
        <div class="modal-content">
            <div class="modal-title">‚öîÔ∏è CANTON ARMY BATTLE RULES</div>
            <div class="rule-item">
                <div class="rule-title">üéØ OBJECTIVE</div>
                <div class="rule-desc">Defend your Canton fortress by destroying enemy threats!</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">‚≠ê SUPER NODES</div>
                <div class="rule-desc">Give 50 points + big privacy boost</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">üéØ REGULAR NODES</div>
                <div class="rule-desc">Give 10 points + small privacy boost</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">‚ò†Ô∏è MALICIOUS NODES</div>
                <div class="rule-desc">Drain 10% privacy if clicked - let them expire naturally!</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">üíÄ CRITICAL THREAT</div>
                <div class="rule-desc">Remove health - avoid clicking!</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">‚ù§Ô∏è HEALTH SYSTEM</div>
                <div class="rule-desc">Start with 10 hearts - lose 1 for each missed node</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">‚öîÔ∏è PRIVACY SHIELD</div>
                <div class="rule-desc">Constantly drains - keep it above 0 or game over!</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">üî• COMBO SYSTEM</div>
                <div class="rule-desc">Click nodes consecutively to multiply your score</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">‚ö†Ô∏è MISS PENALTY</div>
                <div class="rule-desc">-50 points + -1 health for nodes reaching center</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">üéØ PRECISION</div>
                <div class="rule-desc">Miss-clicks reset your combo to zero</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">‚è±Ô∏è TIME LIMIT</div>
                <div class="rule-desc">30 seconds + bonuses from leveling up</div>
            </div>
            <div class="rule-item">
                <div class="rule-title">üìà DIFFICULTY</div>
                <div class="rule-desc">Nodes move 0.1x faster every 1000 points</div>
            </div>
            <button class="close-btn" onclick="closeRules()">GOT IT! ‚öîÔ∏è</button>
        </div>
    </div>

<div class="modal" id="usernameModal">
    <div class="modal-content" style="max-width: 500px;">
        <div class="modal-title">‚öîÔ∏è WELCOME, WARRIOR!</div>
        
        <div style="text-align: center; margin-bottom: 30px;">
            <img id="xProfilePic" src="" alt="Profile" style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid #c4d86f; margin-bottom: 15px; display: none;">
            <div id="xHandleDisplay" style="color: #1DA1F2; font-size: 1.1rem; font-weight: 700; margin-bottom: 5px;"></div>
            <div style="color: #888; font-size: 0.85rem;">Connected via X</div>
        </div>
        
        <div style="margin-bottom: 30px;">
            <label style="display: block; color: #c4d86f; font-size: 0.9rem; margin-bottom: 10px; text-align: left;">
                CHOOSE YOUR WARRIOR NAME
            </label>
            <input 
                type="text" 
                id="warriorNameInput" 
                placeholder="Enter display name..." 
                maxlength="20"
                style="width: 100%; padding: 15px; background: rgba(0,0,0,0.8); border: 2px solid #a4b848; border-radius: 10px; color: white; font-family: 'Orbitron', monospace; font-size: 1.1rem; text-align: center;"
            >
            <div style="text-align: right; color: #888; font-size: 0.75rem; margin-top: 5px;">
                <span id="nameCharCount">0</span>/20
            </div>
        </div>
        
        <button class="close-btn" onclick="confirmUsername()" id="startBattleBtn">
            START BATTLE ‚öîÔ∏è
        </button>
    </div>
</div>

    <div class="gameover-modal" id="gameOver">
        <div class="gameover-content">
            <div class="gameover-title">GAME OVER!</div>
            <div class="final-stats">
                <div class="final-stat">
                    <span class="final-stat-label">Final Score:</span>
                    <span class="final-stat-value" id="finalScore">0</span>
                </div>
                <div class="final-stat">
                    <span class="final-stat-label">Nodes Destroyed:</span>
                    <span class="final-stat-value" id="finalBeans">0</span>
                </div>
                <div class="final-stat">
                    <span class="final-stat-label">Nodes Missed:</span>
                    <span class="final-stat-value" id="finalMissed">0</span>
                </div>
                <div class="final-stat">
                    <span class="final-stat-label">Best Combo:</span>
                    <span class="final-stat-value" id="finalBestCombo">0</span>
                </div>
            </div>
            <div class="gameover-buttons">
                <button class="retry-btn" onclick="restartGame()">FIGHT AGAIN ‚öîÔ∏è</button>
                <button class="share-btn" onclick="shareScore()">üì§ SHARE ON X</button>
            </div>
            <div class="gameover-secondary-buttons">
    <button class="icon-btn" onclick="toggleLeaderboard()" title="Leaderboard">
      üèÜ
    </button>
    <button class="icon-btn" onclick="showRules()" title="Rules">
      üìú
    </button>
  </div>
        </div>
    </div>

    <div class="leaderboard-overlay" id="leaderboardOverlay"></div>
<div class="leaderboard-panel" id="leaderboardPanel">
    <div class="leaderboard-header">
        <div class="leaderboard-title">üèÜ LEADERBOARD</div>
        <div class="leaderboard-subtitle">TOP CANTON WARRIORS</div>
        <button class="leaderboard-close" onclick="toggleLeaderboard()">√ó</button>
    </div><br>
    
    <div class="leaderboard-tabs">
        <button class="leaderboard-tab active" onclick="switchLeaderboard('alltime')" id="alltimeTab">
            üèÜ ALL-TIME
        </button>
        <button class="leaderboard-tab" onclick="switchLeaderboard('weekly')" id="weeklyTab">
            üî• WEEKLY
        </button>
    </div>
    
    <div class="weekly-reset-timer" id="weeklyTimer" style="display: none;">
        üïê Resets in: <span id="resetCountdown">-</span>
    </div>
    
    <div class="leaderboard-list" id="leaderboardList">
        <div class="leaderboard-empty">
            <div style="font-size: 3rem;">üèÜ</div>
            <div style="margin-top: 10px;">No scores yet. Be the first!</div>
        </div>
    </div>
</div>

<!-- Secret Code Modal -->
<div class="modal" id="secretCodeModal">
    <div class="modal-content" style="max-width: 500px;">
        <div class="modal-title">üîê ENTER SECRET CODE</div>
        <div style="text-align: center; margin-bottom: 30px;">
            <img id="eventProfilePic" src="" alt="Profile" style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid #FFD700; margin-bottom: 15px; display: none;">
            <div id="eventHandleDisplay" style="color: #1DA1F2; font-size: 1.1rem; font-weight: 700; margin-bottom: 5px;"></div>
            <div style="color: #888; font-size: 0.85rem;">Connected via X</div>
        </div>
        
        <div style="margin-bottom: 30px;">
            <label style="display: block; color: #FFD700; font-size: 0.9rem; margin-bottom: 10px; text-align: left;">
                ENTER EVENT CODE
            </label>
            <input 
                type="text" 
                id="secretCodeInput" 
                placeholder="Enter secret code..." 
                maxlength="30"
                style="width: 100%; padding: 15px; background: rgba(0,0,0,0.8); border: 2px solid #FFD700; border-radius: 10px; color: white; font-family: Orbitron, monospace; font-size: 1.1rem; text-align: center;">
            <div id="codeError" style="color: #ff4444; font-size: 0.85rem; margin-top: 10px; display: none;"></div>
        </div>
        
        <button class="close-btn" onclick="verifySecretCode()" id="verifyCodeBtn" style="background: linear-gradient(45deg, #FFD700, #FFAB52);">
            VERIFY CODE ‚öîÔ∏è
        </button>
    </div>
</div>

<div class="leaderboard-overlay" id="eventLeaderboardOverlay"></div>
<div class="leaderboard-panel" id="eventLeaderboardPanel">
    <div class="leaderboard-header">
        <div class="leaderboard-title" style="color: #FFD700;">üèÜ CANTON EVENT LEADERBOARD</div>
        <div class="leaderboard-subtitle">EXCLUSIVE EVENT WARRIORS</div>
        <button class="leaderboard-close" onclick="toggleEventLeaderboard()">√ó</button>
    </div>
    
    <div class="leaderboard-list" id="eventLeaderboardList">
        <div class="leaderboard-empty">
            <div style="font-size: 3rem;">üèÜ</div>
            <div style="margin-top: 10px;">No event scores yet. Be the first!</div>
        </div>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-functions-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-check-compat.js"></script>
<script src="https://unpkg.com/@console-wallet/dapp-sdk@latest/dist/esm/index.js" type="module"></script>

<script>

const SECRETCODE = 'armyxcanton';

class GameSession {
  constructor() {
    this.sessionId = null;
    this.sessionToken = null;
    this.startTime = null;
    this.checkpoints = [];
    this.gameMetrics = {
      nodesClicked: 0,
      missedNodes: 0,
      maxCombo: 0,
      scores: []
    };
  }

  async startSession(userId) {
    this.sessionId = this.generateSessionId();
    this.startTime = Date.now();
    this.checkpoints = [];
    this.gameMetrics = {
      nodesClicked: 0,
      missedNodes: 0,
      maxCombo: 0,
      scores: []
    };

    try {
      const sessionRef = database.ref(`sessions/${userId}/${this.sessionId}`);
      await sessionRef.set({
        startTime: this.startTime,
        status: 'active',
        userId: userId
      });
      
      this.sessionToken = await this.generateToken(userId);
      return true;
    } catch (error) {
      return false;
    }
  }

  generateSessionId() {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  async generateToken(userId) {
    const data = `${userId}_${this.sessionId}_${this.startTime}`;
    return btoa(data);
  }

  addCheckpoint(score, combo, nodesDestroyed, privacy) {
    const checkpoint = {
      timestamp: Date.now() - this.startTime,
      score: score,
      combo: combo,
      nodesDestroyed: nodesDestroyed,
      privacy: privacy
    };
    this.checkpoints.push(checkpoint);
  }

  updateMetrics(score, combo, nodesClicked, missedNodes) {
    this.gameMetrics.scores.push(score);
    this.gameMetrics.nodesClicked = nodesClicked;
    this.gameMetrics.missedNodes = missedNodes;
    if (combo > this.gameMetrics.maxCombo) {
      this.gameMetrics.maxCombo = combo;
    }
  }

  isValidSession() {
    if (!this.sessionId || !this.sessionToken) {
        if (!this.sessionId) this.sessionId = this.generateSessionId();
        if (!this.sessionToken) this.sessionToken = 'auto-token-' + Date.now();
    }
    return true;
}

  getSessionData() {
    return {
      sessionId: this.sessionId,
      token: this.sessionToken,
      duration: Date.now() - this.startTime,
      checkpoints: this.checkpoints,
      metrics: this.gameMetrics
    };
  }
}

function sanitizeInput(str) {
    if (!str) return '';
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

let currentLeaderboardView = 'alltime';
let leaderboardOffset = 0;
let allLeaderboardData = [];
const LOAD_MORE_BATCH = 50;

function getWeekStart() {
    const now = new Date();
    const day = now.getDay();
    const diff = now.getDate() - day + (day === 0 ? -6 : 1);
    const monday = new Date(now.setDate(diff));
    monday.setHours(0, 0, 0, 0);
    return monday.getTime();
}

let soundEnabled = true;

function playSound(type) {
    if (!soundEnabled) return;
    try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const frequencies = { 'click': 800, 'super': 1200, 'poison': 200, 'death': 150 };
        oscillator.frequency.value = frequencies[type] || 440;
        oscillator.type = 'sine';
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.1);
        setTimeout(() => audioCtx.close(), 200);
    } catch (e) {}
}

function toggleSound() {
    soundEnabled = !soundEnabled;
    const btn = document.getElementById('sound-btn');
    if (soundEnabled) {
        btn.classList.remove('muted');
        document.getElementById('soundText').textContent = 'SOUND';
    } else {
        btn.classList.add('muted');
        document.getElementById('soundText').textContent = 'MUTED';
    }
}

let gamePaused = false;

function togglePause() {
    if (!game || !game.gameRunning) return;
    
    gamePaused = !gamePaused;
    const btn = document.getElementById('pause-btn');
    const pauseText = document.getElementById('pauseText');
    
    if (gamePaused) {
        btn.style.borderColor = '#ffab52';
        btn.style.color = '#ffab52';
        pauseText.textContent = 'RESUME';
        document.querySelector('.btn-icon').textContent = '‚ñ∂Ô∏è';
        showPauseOverlay();
    } else {
        btn.style.borderColor = '#c4d86f';
        btn.style.color = '#c4d86f';
        pauseText.textContent = 'PAUSE';
        document.querySelector('#pause-btn .btn-icon').textContent = '‚è∏Ô∏è';
        hidePauseOverlay();
    }
}

document.addEventListener('keydown', (e) => {
    if (e.key === 'p' || e.key === 'P') {
        if (game && game.gameRunning) {
            togglePause();
        }
    }
});

function showPauseOverlay() {
    const overlay = document.createElement('div');
    overlay.id = 'pause-overlay';
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:999;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:20px;cursor:pointer;';
    overlay.innerHTML = `
        <div style="font-family:Orbitron,monospace;font-size:4rem;font-weight:900;color:#c4d86f;text-shadow:0 0 20px rgba(196,216,111,0.8);">PAUSED</div>
        <div style="font-size:1.2rem;color:#fff;">Click anywhere to resume</div>
    `;
    overlay.onclick = togglePause;
    document.body.appendChild(overlay);
}

function hidePauseOverlay() {
    const overlay = document.getElementById('pause-overlay');
    if (overlay) overlay.remove();
}

const GameSecurity = (function () {
    let _score = 0;
    let _combo = 0;
    let _bestCombo = 0;
    let _level = 1;
    let _time = 30;
    let _privacyLevel = 100;
    let _nodesDestroyed = 0;
    let _nodesMissed = 0;
    let _health = 10;
    let _invalid = false;

    function validate() {    
        return true;
    }

    function safeSet(fn) {
    fn();

    if (!validate()) {
        if (!_invalid) {
            _invalid = true;
            window.__CAB_INVALID_RUN__ = true;

            try {
                const state = GameSecurity.getState();
                const uid = (window.currentUser && window.currentUser.xUserId) || null;
                const displayName = (window.currentUser && window.currentUser.displayName) || null;
                const xHandle = (window.currentUser && window.currentUser.xHandle) || null;

                if (typeof firebase !== 'undefined' && firebase.database) {
                    firebase.database().ref('suspiciousScores').push({
                        userId: uid,
                        displayName: displayName,
                        xHandle: xHandle,
                        score: state.score,
                        state,
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                }
            } catch (e) {
                console.error('Failed to log suspicious score', e);
            }
        }
    }
}

    return {
        reset() {
            _score = 0;
            _combo = 0;
            _bestCombo = 0;
            _level = 1;
            _time = 30;
            _privacyLevel = 100;
            _nodesDestroyed = 0;
            _nodesMissed = 0;
            _health = 10;
            _invalid = false;
            window.__CAB_INVALID_RUN__ = false;
        },
        addScore(points, combo) {
            safeSet(() => { _score += points * Math.max(1, combo); });
        },
        setCombo(v) {
            safeSet(() => { _combo = Math.max(0, v); if (_combo > _bestCombo) _bestCombo = _combo; });
        },
        resetCombo() {
            safeSet(() => { _combo = 0; });
        },
        incCombo(delta) {
            safeSet(() => { _combo = Math.max(0, _combo + delta); if (_combo > _bestCombo) _bestCombo = _combo; });
        },
        setLevel(v) {
            safeSet(() => { _level = Math.max(1, v); });
        },
        addTime(delta) {
            safeSet(() => { _time += delta; });
        },
        decTime() {
            safeSet(() => { _time--; });
        },
        setTime(v) {
            safeSet(() => { _time = v; });
        },
        damage() {
            safeSet(() => { _health = Math.max(0, _health - 1); });
        },
        heal(amount) {
            safeSet(() => { _health = Math.min(10, _health + amount); });
        },
        setPrivacy(v) {
            safeSet(() => { _privacyLevel = Math.max(0, Math.min(100, v)); });
        },
        addPrivacy(delta) {
            safeSet(() => { _privacyLevel = Math.max(0, Math.min(100, _privacyLevel + delta)); });
        },
        decPrivacy(amount) {
            safeSet(() => { _privacyLevel = Math.max(0, _privacyLevel - amount); });
        },
        incDestroyed() {
            safeSet(() => { _nodesDestroyed++; });
        },
        incMissed() {
            safeSet(() => { _nodesMissed++; });
        },
        getState() {
            return {
                score: _score,
                combo: _combo,
                bestCombo: _bestCombo,
                level: _level,
                time: _time,
                privacyLevel: _privacyLevel,
                nodesDestroyed: _nodesDestroyed,
                nodesMissed: _nodesMissed,
                health: _health
            };
        },
        isInvalid() {
            return _invalid;
        }
    };
})();

(function () {
    const isDesktop = window.innerWidth > 1024 && 
                      !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) &&
                      !('ontouchstart' in window);
    
    if (!isDesktop) {
        return;
    }
    
    let devtoolsOpen = false;
    const threshold = 160;
    
    const check = () => {
        const w = window.outerWidth - window.innerWidth;
        const h = window.outerHeight - window.innerHeight;
        if ((w > threshold || h > threshold) && !devtoolsOpen) {
            devtoolsOpen = true;
            window.__CAB_DEVTOOLS_FLAG__ = true;
            
            const warning = document.createElement('div');
            warning.id = 'devtools-warning';
            warning.style.cssText = 'position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#ff4444;color:#fff;padding:15px 30px;border-radius:10px;font-weight:900;z-index:9999;font-family:Orbitron,monospace;box-shadow:0 0 20px rgba(255,68,68,0.8);';
            warning.textContent = '‚ö†Ô∏è DEVTOOLS DETECTED - SCORE WILL NOT BE SAVED';
            document.body.appendChild(warning);
        }
    };
    window.addEventListener("resize", check);
    setInterval(check, 1000);
})();

class BeanBattleRoyale {
    constructor() {
        this.arena = document.getElementById('arena');
        const s = GameSecurity.getState();
        this.score = s.score;
        this.combo = s.combo;
        this.bestCombo = s.bestCombo;
        this.level = s.level;
        this.time = s.time;
        this.privacyLevel = s.privacyLevel;
        this.nodesDestroyed = s.nodesDestroyed;
        this.nodesMissed = s.nodesMissed;
        this.health = s.health;
        this.gameRunning = true;
        this.nodes = [];
        this.isMobile = window.innerWidth <= 768;
        this.spawnRate = 800;
        this.maxBeans = this.isMobile ? 8 : 15;
        this.privacyDecay = 8;
        this.poisonLifetime = 5000;
        this.updateArenaDimensions();
        this.baseBeanSpeed = 1.0;
        this.nodeSpeed = this.baseBeanSpeed;
        this.difficultyLevel = 0;
        this.initGame();
        this.gameLoop();
        this.spawnLoop();
        this.timer();
        this.setupClickHandler();
    }

    syncFromSecurity() {
        const s = GameSecurity.getState();
        this.score = s.score;
        this.combo = s.combo;
        this.bestCombo = s.bestCombo;
        this.level = s.level;
        this.time = s.time;
        this.privacyLevel = s.privacyLevel;
        this.nodesDestroyed = s.nodesDestroyed;
        this.nodesMissed = s.nodesMissed;
        this.health = s.health;
    }

    updateArenaDimensions() {
        const arenaRect = this.arena.getBoundingClientRect();
        this.arenaWidth = arenaRect.width - 60;
        this.arenaHeight = arenaRect.height - 60;
        this.centerX = arenaRect.width / 2 - 15;
        this.centerY = arenaRect.height / 2 - 20;
    }

    initGame() {
        this.initHealthBar();
        this.updateUI();
        this.spawnPlayerBean();
    }

    initHealthBar() {
        const healthHearts = document.getElementById('healthBar');
        healthHearts.innerHTML = '';
        for (let i = 0; i < 10; i++) {
            const heart = document.createElement('div');
            heart.className = 'heart';
            heart.innerHTML = '‚ù§Ô∏è';
            heart.id = `heart-${i}`;
            healthHearts.appendChild(heart);
        }
    }

    updateHealthBar() {
        this.syncFromSecurity();
        for (let i = 0; i < 10; i++) {
            const heart = document.getElementById(`heart-${i}`);
            if (i >= this.health) {
                heart.style.opacity = '0.3';
                heart.style.filter = 'grayscale(100%)';
            } else {
                heart.style.opacity = '1';
                heart.style.filter = 'none';
            }
        }
    }

    calculateDifficulty() {
        this.syncFromSecurity();
        const newDifficultyLevel = Math.floor(this.score / 1000);
        if (newDifficultyLevel !== this.difficultyLevel) {
            this.difficultyLevel = newDifficultyLevel;
            this.scaleDifficulty();
        }
    }

    scaleDifficulty() {
        this.nodeSpeed = this.baseBeanSpeed + (this.difficultyLevel * 0.1);
    }

    takeDamage() {
        GameSecurity.damage();
        this.syncFromSecurity();
        this.updateHealthBar();
        this.showHealthDamage();
        if (this.health <= 0) {
            this.endGame("FORTRESS DESTROYED!");
        }
    }

    showHealthDamage() {
        const damage = document.createElement('div');
        damage.className = 'health-damage';
        damage.innerHTML = '-1 ‚ù§Ô∏è';
        this.arena.appendChild(damage);
        setTimeout(() => {
            if (damage.parentNode) damage.remove();
        }, 1500);
    }

    setupClickHandler() {
    const isMobile = 'ontouchstart' in window;
    
    const handleMissClick = (e) => {
        if (!e.target.classList.contains('node') && !e.target.classList.contains('player')) {
            GameSecurity.resetCombo();
            this.syncFromSecurity();
            this.updateUI();
        }
    };
    
    if (!isMobile) {
        this.arena.addEventListener('click', handleMissClick);
    } else {
        this.arena.addEventListener('touchend', (e) => {
            const touch = e.changedTouches[0];
            const touchX = touch.clientX;
            const touchY = touch.clientY;
            
            let nearNode = false;
            this.nodes.forEach(nodeData => {
                const rect = nodeData.element.getBoundingClientRect();
                const nodeX = rect.left + rect.width / 2;
                const nodeY = rect.top + rect.height / 2;
                const distance = Math.sqrt((touchX - nodeX)**2 + (touchY - nodeY)**2);
                
                if (distance < 40) {
                    nearNode = true;
                }
            });
            
            const element = document.elementFromPoint(touchX, touchY);
            if (!nearNode && (!element || (!element.classList.contains('node') && !element.classList.contains('player')))) {
                GameSecurity.resetCombo();
                this.syncFromSecurity();
                this.updateUI();
            }
        }, { passive: true });
    }
}

    spawnPlayerBean() {
    const playerBean = document.createElement('div');
    playerBean.className = 'node player';
    playerBean.innerHTML = '<img src="cn-favicon-05%201-1.webp" style="width: 40px; height: 40px;">';
    const arenaRect = this.arena.getBoundingClientRect();
    const centerX = arenaRect.width / 2 - 15;
    const centerY = arenaRect.height / 2 - 20;
    playerBean.style.left = `${centerX}px`;
    playerBean.style.top = `${centerY}px`;
    
    playerBean.style.padding = '15px';
    playerBean.style.margin = '-15px';
    
    this.arena.appendChild(playerBean);
}


spawnEnemyBean() {
    if (this.nodes.length >= this.maxBeans || !this.gameRunning) return;
    const node = document.createElement('div');
    const rand = Math.random();
    let nodeType, isSuper = false, isPoison = false;
    if (rand < 0.15) {
        nodeType = 'poison';
        isPoison = true;
        node.className = 'node poison';
        node.innerHTML = '<img src="eth.png" style="width: 30px; height: 30px;">';
    } else if (rand < 0.20) {
        nodeType = 'deadly-poison';
        isPoison = true;
        node.className = 'node deadly-poison';
        node.innerHTML = '<img src="xrp.png" style="width: 24px; height: 24px; object-fit: contain;">';
    } else if (rand < 0.35) {
        nodeType = 'super';
        isSuper = true;
        node.className = 'node super';
        node.innerHTML = '<img src="cc.png" style="width: 30px; height: 30px;">';
    } else {
        nodeType = 'enemy';
        node.className = 'node enemy';
        node.innerHTML = '<img src="cc.png" style="width: 30px; height: 30px;">';
    }
    const side = Math.floor(Math.random() * 4);
    let x, y;
    switch(side) {
        case 0:
            x = Math.random() * this.arenaWidth;
            y = 0;
            break;
        case 1:
            x = this.arenaWidth;
            y = Math.random() * this.arenaHeight;
            break;
        case 2:
            x = Math.random() * this.arenaWidth;
            y = this.arenaHeight;
            break;
        case 3:
            x = 0;
            y = Math.random() * this.arenaHeight;
            break;
    }
    node.style.left = `${x}px`;
    node.style.top = `${y}px`;
    
    node.style.padding = '15px';
    node.style.margin = '-15px';
    
    const nodeData = {
        element: node,
        type: nodeType,
        spawnTime: Date.now(),
        poisonExpireTime: isPoison ? Date.now() + this.poisonLifetime : null
    };

    const handleDestroy = (e) => {
        e.stopPropagation();

        if (nodeData.destroyed) return;
        nodeData.destroyed = true;

        this.destroyBean(node, nodeType, nodeData);
    };

    if ('ontouchstart' in window) {
        node.addEventListener('touchend', handleDestroy, { passive: true });
    } else {
        node.addEventListener('click', handleDestroy);
    }

    this.arena.appendChild(node);
    this.nodes.push(nodeData);
    this.moveBean(node);
    if (isPoison) {
        setTimeout(() => {
            if (node.parentNode && this.nodes.includes(nodeData)) {
                node.classList.add('expiring');
            }
        }, this.poisonLifetime - 1000);
        setTimeout(() => {
            if (node.parentNode && this.nodes.includes(nodeData)) {
                this.removeBeanSafely(nodeData);
            }
        }, this.poisonLifetime);
    }
}

    removeBeanSafely(nodeData) {
        if (nodeData.element.parentNode) {
            nodeData.element.remove();
        }
        this.nodes = this.nodes.filter(b => b !== nodeData);
    }

    moveBean(nodeElement) {
    const startX = parseInt(nodeElement.style.left);
    const startY = parseInt(nodeElement.style.top);
    const targetX = this.centerX + (Math.random() - 0.5) * 100;
    const targetY = this.centerY + (Math.random() - 0.5) * 100;
    const baseDuration = 1800 + Math.random() * 1300;
    const duration = baseDuration / (this.nodeSpeed * 1.3);
    let startTime = Date.now();
    let totalPausedTime = 0;
    let pauseStartTime = null;

    const animate = () => {
        if (!this.gameRunning || !nodeElement.parentNode) return;

        if (gamePaused) {
            if (pauseStartTime === null) {
                pauseStartTime = Date.now();
            }
            requestAnimationFrame(animate);
            return;
        }

        if (pauseStartTime !== null) {
            totalPausedTime += Date.now() - pauseStartTime;
            pauseStartTime = null;
        }

        const elapsed = Date.now() - startTime - totalPausedTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeOut = 1 - Math.pow(1 - progress, 3);
        const currentX = startX + (targetX - startX) * easeOut;
        const currentY = startY + (targetY - startY) * easeOut;
        nodeElement.style.left = `${currentX}px`;
        nodeElement.style.top = `${currentY}px`;
        if (progress < 1) {
            requestAnimationFrame(animate);
        } else {
            const nodeData = this.nodes.find(b => b.element === nodeElement);
            if (nodeData && nodeData.type !== 'poison' && nodeData.type !== 'deadly-poison') {
                this.applyMissPenalty(nodeElement);
            } else if (nodeData) {
                this.removeBeanSafely(nodeData);
            }
        }
    };
    animate();
}

    applyMissPenalty(nodeElement) {
        const nodeData = this.nodes.find(b => b.element === nodeElement);
        if (nodeData) {
            GameSecurity.incMissed();
            this.takeDamage();
            GameSecurity.resetCombo();
            this.syncFromSecurity();
            this.removeBeanSafely(nodeData);
            this.showMissPenalty();
            this.updateUI();
        }
    }

    showMissPenalty() {
        const penalty = document.createElement('div');
        penalty.className = 'miss-penalty';
        penalty.innerHTML = 'MISSED! -1 ‚ù§Ô∏è';
        this.arena.appendChild(penalty);
        setTimeout(() => {
            if (penalty.parentNode) penalty.remove();
        }, 1500);
    }

    destroyBean(nodeElement, nodeType, nodeData) {
    if (!this.gameRunning || !nodeElement.parentNode) return;
    this.syncFromSecurity();
    
    if (nodeType === 'poison') {
        playSound('poison');
        GameSecurity.decPrivacy(10);
        GameSecurity.resetCombo();
        this.syncFromSecurity();
        this.showPoisonWarning();
        this.removeBeanSafely(nodeData);
        this.updateUI();
        return;
    }
    
    if (nodeType === 'deadly-poison') {
        playSound('poison');
        this.takeDamage();
        GameSecurity.resetCombo();
        this.syncFromSecurity();
        this.showDeadlyPoisonWarning();
        this.removeBeanSafely(nodeData);
        this.updateUI();
        return;
    }
    
    const points = nodeType === 'super' ? 50 : 10;

if (nodeType === 'super') {
    playSound('super');
} else {
    playSound('click');
}

GameSecurity.addScore(points, this.combo);

GameSecurity.incCombo(nodeType === 'super' ? 3 : 1);

GameSecurity.addPrivacy(nodeType === 'super' ? 15 : 8);
GameSecurity.incDestroyed();
this.syncFromSecurity();

this.removeBeanSafely(nodeData);

if (this.combo >= 5) {
    this.showCombo();
}

this.calculateDifficulty();
this.updateUI();
this.checkLevelUp();
}

    showPoisonWarning() {
        const warning = document.createElement('div');
        warning.className = 'poison-warning';
        warning.innerHTML = 'POISON! -10%';
        this.arena.appendChild(warning);
        setTimeout(() => {
            if (warning.parentNode) warning.remove();
        }, 1500);
    }

    showDeadlyPoisonWarning() {
        const warning = document.createElement('div');
        warning.className = 'poison-warning';
        warning.innerHTML = 'CRITICAL THREAT! -1 ‚ù§Ô∏è';
        warning.style.color = '#ff0000';
        this.arena.appendChild(warning);
        setTimeout(() => {
            if (warning.parentNode) warning.remove();
        }, 2000);
    }

    showCombo() {
        const comboDisplay = document.createElement('div');
        comboDisplay.className = 'combo-display';
        comboDisplay.innerHTML = `COMBO x${this.combo}!`;
        this.arena.appendChild(comboDisplay);
        setTimeout(() => {
            if (comboDisplay.parentNode) comboDisplay.remove();
        }, 650);
    }

    checkLevelUp() {
        this.syncFromSecurity();
        const newLevel = Math.floor(this.nodesDestroyed / 10) + 1;
        if (newLevel > this.level) {
            GameSecurity.setLevel(newLevel);
            GameSecurity.addTime(10);
            this.syncFromSecurity();
        }
    }

    updateUI() {
        this.syncFromSecurity();
        document.getElementById('score').textContent = this.score;
        document.getElementById('combo').textContent = this.combo;
        document.getElementById('level').textContent = this.level;
        document.getElementById('time').textContent = this.time;
        document.getElementById('missed').textContent = this.nodesMissed;
        const privacyLevel = document.getElementById('privacyLevel');
        privacyLevel.style.width = `${this.privacyLevel}%`;
        document.getElementById('privacyText').textContent = `${Math.floor(this.privacyLevel)}%`;
        this.updateHealthBar();
    }

    gameLoop() {
    if (!this.gameRunning) return;
    if (gamePaused) {
        setTimeout(() => this.gameLoop(), 100);
        return;
    }

    GameSecurity.decPrivacy(this.privacyDecay / 10);
    this.syncFromSecurity();

    if (this.privacyLevel <= 0) {
        this.endGame('PRIVACY CRASH!');
        return;
    }

    const currentTime = Date.now();
    if (currentTime - lastCheckpointTime > 10000) {
        currentSession.addCheckpoint(
            this.score,
            this.combo,
            this.nodesDestroyed,
            this.privacyLevel
        );
        lastCheckpointTime = currentTime;
    }
    
    currentSession.updateMetrics(
        this.score,
        this.combo,
        this.nodesDestroyed,
        this.nodesMissed
    );

    this.updateUI();
    setTimeout(() => this.gameLoop(), 100);
}

    spawnLoop() {
        if (!this.gameRunning) return;
        if (gamePaused) {
            setTimeout(() => this.spawnLoop(), this.spawnRate);
            return;
        }
        this.spawnEnemyBean();
        setTimeout(() => this.spawnLoop(), this.spawnRate);
    }

    timer() {
        if (!this.gameRunning) return;
        if (gamePaused) {
            setTimeout(() => this.timer(), 1000);
            return;
        }
        GameSecurity.decTime();
        this.syncFromSecurity();
        if (this.time <= 0) {
            this.endGame("TIME'S UP!");
            return;
        }
        setTimeout(() => this.timer(), 1000);
    }

  async endGame(reason = 'GAME OVER!') {
  playSound('death');
  this.gameRunning = false;
  
  this.nodes.forEach(nodeData => {
    if (nodeData.element && nodeData.element.parentNode) {
      nodeData.element.style.pointerEvents = 'none';
      nodeData.element.style.opacity = '0.5';
    }
  });

  this.syncFromSecurity();
  
  document.getElementById('gameOver').style.display = 'flex';
  document.getElementById('finalScore').textContent = this.score;
  document.getElementById('finalBeans').textContent = this.nodesDestroyed;
  document.getElementById('finalMissed').textContent = this.nodesMissed;
  document.getElementById('finalBestCombo').textContent = this.bestCombo;

  if (currentSession && currentSession.sessionId) {
    const userId = currentUser.xUserId || 'guest_' + Date.now();
    database.ref(`sessions/${userId}/${currentSession.sessionId}`).update({
      status: 'completed',
      finalScore: this.score,
      nodesDestroyed: this.nodesDestroyed,
      nodesMissed: this.nodesMissed,
      bestCombo: this.bestCombo,
      endTime: Date.now()
    });
  }

  if (!window.CAB_DEVTOOLS_FLAG && !GameSecurity.isInvalid() && !isGuestMode) {
    const scoreData = {
      score: this.score,
      nodesDestroyed: this.nodesDestroyed,
      nodesMissed: this.nodesMissed,
      bestCombo: this.bestCombo
    };
    
    submitScoreToFirebase(scoreData);
  } else if (isGuestMode) {
  } else if (window.CAB_DEVTOOLS_FLAG) {
    showSubmissionError('DevTools detected - score not saved');
  } else if (GameSecurity.isInvalid()) {
    showSubmissionError('Invalid game detected - score not saved');
  }

  if (!isGuestMode && currentUser && currentUser.xUserId) {
    const today = new Date().toISOString().split('T')[0];
    const gamesRef = database.ref(`dailyGames/${currentUser.xUserId}/${today}`);
    const snapshot = await gamesRef.once('value');
    const gamesPlayed = snapshot.val() || 0;
    
    if (gamesPlayed >= 10) {
      const restartBtn = document.getElementById('restartBtn');
      if (restartBtn) {
        restartBtn.disabled = true;
        restartBtn.style.opacity = '0.5';
        restartBtn.style.cursor = 'not-allowed';
        restartBtn.onclick = null;
      }
    }
  }
}
}

async function loadLeaderboard(loadMore = false) {
  const list = document.getElementById('leaderboardList');
  
  if (!loadMore) {
    list.innerHTML = '<div class="leaderboard-empty"><div style="font-size: 2rem;">‚è≥</div><div style="margin-top: 10px;">Loading scores...</div></div>';
    leaderboardOffset = 0;
  }
  
  try {
    if (!loadMore) {
      if (currentLeaderboardView === 'weekly') {
        const weekId = getWeekIdentifier();
        const snapshot = await database.ref(`leaderboard/weekly/${weekId}`).once('value');
        const data = snapshot.val();
        allLeaderboardData = data ? Object.values(data) : [];
      } else {
        const snapshot = await database.ref('leaderboard/alltime').once('value');
        const data = snapshot.val();
        allLeaderboardData = data ? Object.values(data) : [];
      }
      
      allLeaderboardData.sort((a, b) => b.score - a.score);
    }
    
    if (allLeaderboardData.length === 0) {
      const emptyIcon = currentLeaderboardView === 'weekly' ? 'üî•' : 'üèÜ';
      list.innerHTML = `
        <div class="leaderboard-empty">
          <div style="font-size: 3rem;">${emptyIcon}</div>
          <div style="margin-top: 10px;">No scores yet. Be the first!</div>
        </div>
      `;
      return;
    }
    
    if (!loadMore) {
      list.innerHTML = '';
      
      let currentUserRank = -1;
      if (!isGuestMode && currentUser.xUserId) {
        currentUserRank = allLeaderboardData.findIndex(entry => entry.userId === currentUser.xUserId);
      }
      
      if (currentUserRank > 5) {
        const userEntry = allLeaderboardData[currentUserRank];
        const userItem = createLeaderboardItem(userEntry, currentUserRank, true);
        list.appendChild(userItem);
        
        const separator = document.createElement('div');
        separator.style.cssText = 'height: 2px; background: rgba(196, 216, 111, 0.3); margin: 15px 0;';
        list.appendChild(separator);
      }
    }
    
    const endIndex = Math.min(leaderboardOffset + LOAD_MORE_BATCH, allLeaderboardData.length);
    
    for (let i = leaderboardOffset; i < endIndex; i++) {
      const entry = allLeaderboardData[i];
      const item = createLeaderboardItem(entry, i, false);
      list.appendChild(item);
    }
    
    leaderboardOffset = endIndex;
    
    const oldButton = document.getElementById('loadMoreButton');
    if (oldButton) oldButton.remove();
    
    if (leaderboardOffset < allLeaderboardData.length) {
      const loadMoreBtn = document.createElement('button');
      loadMoreBtn.id = 'loadMoreButton';
      loadMoreBtn.className = 'load-more-btn';
      loadMoreBtn.innerHTML = `
        üì• LOAD MORE (${allLeaderboardData.length - leaderboardOffset} remaining)
      `;
      loadMoreBtn.onclick = () => loadLeaderboard(true);
      list.appendChild(loadMoreBtn);
    }
    
  } catch (error) {
    console.error('Failed to load leaderboard:', error);
    list.innerHTML = `
      <div class="leaderboard-empty">
        <div style="font-size: 2rem;">‚ùå</div>
        <div style="margin-top: 10px;">Failed to load leaderboard</div>
      </div>
    `;
  }
}

function createLeaderboardItem(entry, index, isUserHighlight) {
  const item = document.createElement('div');
  item.className = 'leaderboard-item';
  
  const isCurrentUser = !isGuestMode && currentUser.xUserId && entry.userId === currentUser.xUserId;
  
  if (currentLeaderboardView === 'weekly' && index < 3) {
    item.classList.add('weekly-top');
  }
  
  if (isCurrentUser) {
    item.style.borderColor = '#1DA1F2';
    item.style.background = 'rgba(29, 161, 242, 0.15)';
  }
  
  if (isUserHighlight) {
    item.style.background = 'rgba(196, 216, 111, 0.2)';
    item.style.borderColor = '#ffab52';
  }
  
  let crownEmoji = '';
  if (currentLeaderboardView === 'weekly' && index === 0) {
    crownEmoji = '<span class="weekly-crown">üëë</span>';
  }
  
  const flaggedIcon = entry.flagged ? ' <span style="color: #ff4444;">‚ö†Ô∏è</span>' : '';
  
  item.innerHTML = `
    <div class="leaderboard-rank">${index + 1}</div>
    <div class="leaderboard-player">
      <div class="leaderboard-player-name">${sanitizeInput(entry.username)}${crownEmoji}${flaggedIcon}</div>
      ${isCurrentUser ? `<div style="font-size: 0.75rem; color: #1DA1F2; margin-top: 2px;">${sanitizeInput(entry.xHandle || '')}</div>` : ''}
    </div>
    <div class="leaderboard-score">${entry.score}</div>
  `;
  
  return item;
}

function switchLeaderboard(type) {
  currentLeaderboardView = type;
  leaderboardOffset = 0;
  document.getElementById('alltimeTab').classList.toggle('active', type === 'alltime');
  document.getElementById('weeklyTab').classList.toggle('active', type === 'weekly');
  
  const timer = document.getElementById('weeklyTimer');
  if (type === 'weekly') {
    timer.style.display = 'block';
    updateResetCountdown();
  } else {
    timer.style.display = 'none';
  }
  
  loadLeaderboard();
}

function updateResetCountdown() {
    const now = new Date();
    const nextMonday = new Date(now);
    const day = now.getDay();
    const daysUntilMonday = (day === 0 ? 1 : 8 - day);
    nextMonday.setDate(now.getDate() + daysUntilMonday);
    nextMonday.setHours(0, 0, 0, 0);
    
    const diff = nextMonday - now;
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    
    const countdown = document.getElementById('resetCountdown');
    if (countdown) {
        countdown.textContent = `${days}d ${hours}h ${minutes}m`;
    }
}

setInterval(() => {
    if (currentLeaderboardView === 'weekly') {
        updateResetCountdown();
    }
}, 60000);

function toggleLeaderboard() {
    if (isEventMode) {
        toggleEventLeaderboard();
    } else {
        const overlay = document.getElementById('leaderboardOverlay');
        const panel = document.getElementById('leaderboardPanel');
        overlay.classList.toggle('active');
        panel.classList.toggle('active');
        
        if (panel.classList.contains('active')) {
            loadLeaderboard();
        }
    }
}

let game = null;
let currentSession = new GameSession();
let lastCheckpointTime = 0;

async function startGame() {
    const userId = currentUser.xUserId || 'guest_' + Date.now();
    const sessionStarted = await currentSession.startSession(userId);
    
    if (!sessionStarted) {
        alert('Failed to start game session. Please try again.');
        return;
    }
    
    playSound('super');
    document.getElementById('hero').style.display = 'none';
    document.getElementById('gameContainer').classList.add('active');
    game = new BeanBattleRoyale();
}

async function restartGame() {
    if (isEventMode && !isGuestMode && currentUser && currentUser.xUserId) {
        const userId = currentUser.xUserId;
        const eventPlaysRef = database.ref(`eventPlays/${userId}`);
        const playsSnapshot = await eventPlaysRef.once('value');
        const playsData = playsSnapshot.val();
        
        const today = new Date().toISOString().split('T')[0];
        let gamesPlayed = 0;
        
        if (playsData && playsData.date === today) {
            gamesPlayed = playsData.count || 0;
        }
        
        if (gamesPlayed >= 10) {
            alert('‚öîÔ∏è Event Limit Reached!\n\nYou have played 10/10 event games today.\nCome back tomorrow to play more!');
            return;
        }
    }

    document.getElementById('gameOver').style.display = 'none';
    const arena = document.getElementById('arena');
    arena.innerHTML = '';
    arena.innerHTML = 
        `<div class="privacy-container">
            <div class="privacy-label">‚öîÔ∏è PRIVACY SHIELD</div>
            <div class="privacy-bar-container">
                <div class="privacy-bar" id="privacyLevel" style="width: 100%;">
                    <span id="privacyText">100%</span>
                </div>
            </div>
        </div>`;
    
    const userId = currentUser.xUserId || 'guest_' + Date.now();
    currentSession = new GameSession();
    lastCheckpointTime = 0;
    
    try {
        await currentSession.startSession(userId);
    } catch (error) {
        console.warn('Session tracking unavailable:', error);
    }
    
    window.CAB_DEVTOOLS_FLAG = false;
    GameSecurity.reset();
    game = new BeanBattleRoyale();
}

function showRules() {
    document.getElementById('rulesModal').classList.add('active');
}

function closeRules() {
    document.getElementById('rulesModal').classList.remove('active');
}

function shareScore() {
    const score = document.getElementById('finalScore').textContent;
    const gameUrl = window.location.href;
    const tweetText = `I just scored ${score} points in @CantonArmy Battle! üí£‚öîÔ∏è\n\nThese nodes came for my fortress and got REKT.\n\nThink you can survive longer?\n\nPlay here: ${gameUrl}`;
    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`;
    window.open(twitterUrl, '_blank');
}

let isGuestMode = false;
let isMockAuth = false;
let currentUser = {
    xHandle: null,
    xUserId: null,
    displayName: null,
    profilePic: null
};

let auth0Client = null;

async function initAuth0() {
    try {
        auth0Client = await auth0.createAuth0Client({
            domain: 'cantonarmy.us.auth0.com',
            clientId: '8P3i4eBffFkJjouj2jV1l6qfsxYwlsOP',
            authorizationParams: {
                redirect_uri: window.location.origin + '/cantonbattle/',
                connection: 'twitter'
            }
        });
        
        const query = window.location.search;
        if (query.includes('code=') && query.includes('state=')) {
            await handleAuthCallback();
        }
    } catch (error) {
        console.error('Auth0 initialization error:', error);
        alert('‚ö†Ô∏è Authentication setup failed. Please try again.');
    }
}

initAuth0();

async function startGameAsGuest() {
    isGuestMode = true;
    currentUser = { xHandle: null, xUserId: null, displayName: 'Guest', profilePic: null };
    
    const userId = 'guest_' + Date.now();
    const sessionStarted = await currentSession.startSession(userId);
    
    if (!sessionStarted) {
        alert('Failed to start game. Please try again.');
        return;
    }
    
    playSound('super');
    document.getElementById('hero').style.display = 'none';
    document.getElementById('gameContainer').classList.add('active');
    game = new BeanBattleRoyale();
}

async function signInWithX() {
    try {
        await auth0Client.loginWithPopup({
            authorizationParams: {
                connection: 'twitter',
                scope: 'openid profile email',
                audience: 'https://cantonarmy.us.auth0.com/userinfo'
            }
        });

                const auth0Token = await auth0Client.getTokenSilently({
            authorizationParams: {
                audience: 'https://cantonarmy.us.auth0.com/userinfo'
            }
        });
        
        const response = await fetch('https://us-central1-canton-army-battle.cloudfunctions.net/createFirebaseToken', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ auth0Token: auth0Token })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error('Backend error: ' + errorText);
        }

        const result = await response.json();
        const { firebaseToken, userId, xHandle, picture } = result;
        
        
        await firebase.auth().signInWithCustomToken(firebaseToken);
        
        const auth0User = await auth0Client.getUser();
        currentUser = {
            xUserId: userId,
            xHandle: xHandle,
            name: auth0User.name,
            profilePic: picture,
            email: auth0User.email
        };
        
        const savedUsername = await getSavedUsername(currentUser.xUserId);
        
        if (savedUsername) {
            currentUser.displayName = savedUsername;
            const sessionStarted = await currentSession.startSession(currentUser.xUserId);
            
            if (!sessionStarted) {
                alert('Failed to start session. Please try again.');
                return;
            }
            
            document.getElementById('hero').style.display = 'none';
            document.getElementById('gameContainer').classList.add('active');
            playSound('super');
            game = new BeanBattleRoyale();
        } else {
            showUsernameModal({
                xHandle: xHandle,
                xUserId: userId,
                profilePic: picture,
                name: auth0User.name
            });
        }
        
    } catch (error) {
        console.error('‚ùå Login failed:', error);
        alert('Login failed: ' + error.message);
    }
}

async function handleAuthCallback() {
    try {
        await auth0Client.handleRedirectCallback();
        
        const user = await auth0Client.getUser();
        
        if (user) {
            const xUserData = {
                xUserId: user.sub,
                xHandle: '@' + (user.nickname || user.name),
                profilePic: user.picture,
                name: user.name || user.nickname
            };
            
            window.history.replaceState({}, document.title, window.location.pathname);
            
            showUsernameModal(xUserData);
        }
    } catch (error) {
        console.error('Callback error:', error);
        alert('‚ö†Ô∏è Authentication callback failed.');
    }
}

async function showUsernameModal(xUserData) {
  isGuestMode = false;
  currentUser.xHandle = xUserData.xHandle;
  currentUser.xUserId = xUserData.xUserId;
  currentUser.profilePic = xUserData.profilePic;
  
  const savedUsername = await getSavedUsername(xUserData.xUserId);
  
  if (savedUsername) {
    currentUser.displayName = savedUsername;
    
    const userId = currentUser.xUserId;
    
    try {
      await currentSession.startSession(userId);
    } catch (error) {
      console.warn('Session tracking unavailable:', error);
    }
    
    document.getElementById('hero').style.display = 'none';
    document.getElementById('gameContainer').classList.add('active');
    playSound('super');
    game = new BeanBattleRoyale();
    return;
  }
  
  const profilePic = document.getElementById('xProfilePic');
  const handleDisplay = document.getElementById('xHandleDisplay');
  const nameInput = document.getElementById('warriorNameInput');
  
  if (xUserData.profilePic) {
    profilePic.src = xUserData.profilePic;
    profilePic.style.display = 'block';
  }
  
  handleDisplay.textContent = xUserData.xHandle;
  nameInput.value = xUserData.name || xUserData.xHandle.replace('@', '');
  updateCharCount();
  
  document.getElementById('usernameModal').classList.add('active');
  nameInput.focus();
  
  nameInput.onkeypress = function(e) {
    if (e.key === 'Enter') {
      confirmUsername();
    }
  };
}

async function getSavedUsername(xUserId) {
  if (!xUserId) {
    console.warn('‚ö†Ô∏è No user ID provided');
    return null;
  }
  
  try {
    
    const snapshot = await database.ref(`users/${xUserId}/displayName`).once('value');
    
    if (snapshot.exists()) {
      const username = snapshot.val();
      return username;
    }
    
    return null;
    
  } catch (error) {
    console.error('‚ùå Error getting saved username:', error);
    return null;
  }
}

function updateCharCount() {
    const input = document.getElementById('warriorNameInput');
    const count = document.getElementById('nameCharCount');
    count.textContent = input.value.length;
}

async function isUsernameTaken(displayName, currentXUserId) {
    try {
        const snapshot = await database.ref('users').once('value');
        const users = snapshot.val();
        
        if (!users) return false;
        
        for (const [xUserId, userData] of Object.entries(users)) {
            if (userData.displayName && 
                userData.displayName.toLowerCase() === displayName.toLowerCase()) {
                return true;
            }
        }
        
        return false;
    } catch (error) {
        console.error('Error checking username:', error);
        return false;
    }
}

async function confirmUsername() {
    const nameInput = document.getElementById('warriorNameInput');
    const displayName = nameInput.value.trim();
    
    const existingError = document.getElementById('usernameError');
    if (existingError) existingError.remove();
    
    if (!displayName) {
        showUsernameError('Please enter a warrior name!');
        return;
    }
    
    if (!/^[a-zA-Z0-9\s_-]+$/.test(displayName)) {
        showUsernameError('Name can only contain letters, numbers, spaces, and _ -');
        return;
    }

    const startBtn = document.getElementById('startBattleBtn');
    startBtn.disabled = true;
    startBtn.textContent = 'CHECKING...';

    try {
        const snapshot = await database.ref('users').once('value');
        const users = snapshot.val();
        
        if (users) {
            for (const [xUserId, userData] of Object.entries(users)) {
                if (userData && userData.displayName && 
                    userData.displayName.toLowerCase() === displayName.toLowerCase()) {
                    startBtn.disabled = false;
                    startBtn.textContent = 'START BATTLE';
                    showUsernameError('‚ö†Ô∏è Username "' + displayName + '" already exists! Please choose another name.');
                    nameInput.focus();
                    return;
                }
            }
        }
    } catch (error) {
        console.error('Error checking username:', error);
        startBtn.disabled = false;
        startBtn.textContent = 'START BATTLE';
        showUsernameError('Error checking username. Please try again.');
        return;
    }
    
    startBtn.disabled = false;
    startBtn.textContent = 'START BATTLE';
    
    currentUser.displayName = displayName;
    await saveUsernameForUser(currentUser.xUserId, displayName);
    
    const userId = currentUser.xUserId;
    const sessionStarted = await currentSession.startSession(userId);
    
    if (!sessionStarted) {
        showUsernameError('Failed to start game session. Please try again.');
        return;
    }
    
    document.getElementById('usernameModal').classList.remove('active');
    document.getElementById('hero').style.display = 'none';
    document.getElementById('gameContainer').classList.add('active');
    playSound('super');
    game = new BeanBattleRoyale();
}

function showUsernameError(message) {
  const nameInput = document.getElementById('warriorNameInput');
  
  const existingError = document.getElementById('usernameError');
  if (existingError) existingError.remove();
  
  const errorDiv = document.createElement('div');
  errorDiv.id = 'usernameError';
  errorDiv.style.cssText = `
    color: #ff4444;
    background: rgba(255, 68, 68, 0.1);
    border: 2px solid #ff4444;
    border-radius: 10px;
    padding: 10px 15px;
    margin-top: 10px;
    font-size: 0.9rem;
    font-weight: 600;
    text-align: center;
    animation: shake 0.5s;
  `;
  errorDiv.textContent = message;
  
  nameInput.parentElement.appendChild(errorDiv);
  
  nameInput.style.animation = 'shake 0.5s';
  nameInput.style.borderColor = '#ff4444';
  
  setTimeout(() => {
    nameInput.style.animation = '';
    nameInput.style.borderColor = '#a4b848';
  }, 500);
}

async function saveUsernameForUser(xUserId, displayName) {
  try {
    await database.ref(`users/${xUserId}`).set({
      displayName: displayName,
      xUserId: xUserId,
      xHandle: currentUser.xHandle,
      profilePic: currentUser.profilePic,
      updatedAt: Date.now()
    });
        
    const key = 'cantonArmyLeaderboard';
    let leaderboard = JSON.parse(localStorage.getItem(key) || '[]');
    const existingIndex = leaderboard.findIndex(entry => entry.xUserId === xUserId);
    
    if (existingIndex >= 0) {
      leaderboard[existingIndex].displayName = displayName;
    } else {
      leaderboard.push({
        xUserId: xUserId,
        xHandle: currentUser.xHandle,
        displayName: displayName,
        profilePic: currentUser.profilePic,
        score: 0
      });
    }
    
    localStorage.setItem(key, JSON.stringify(leaderboard));
  } catch (error) {
    console.error('Error saving username:', error);
  }
}

let promoShown = false;

function showPromoModal() {
    if (promoShown) return;
    promoShown = true;
        
    document.getElementById('promoModal').style.display = 'flex';
    
    setTimeout(closePromo, 15000);
}

function closePromo() {
    document.getElementById('promoModal').style.display = 'none';
}

function closePromoAndPlay() {
    closePromo();
}

let isEventMode = false;
let eventUser = null;
const SECRET_CODE = "armyxcanton";

async function startCantonEvent() {
    isEventMode = true;
    
    if (!isGuestMode && currentUser && currentUser.xUserId) {
        const userId = currentUser.xUserId;
        const eventPlaysRef = database.ref(`eventPlays/${userId}`);
        const playsSnapshot = await eventPlaysRef.once('value');
        const playsData = playsSnapshot.val();
        
        const today = new Date().toISOString().split('T')[0];
        let gamesPlayed = 0;
        
        if (playsData && playsData.date === today) {
            gamesPlayed = playsData.count || 0;
        }
        
        if (gamesPlayed >= 10) {
            alert('‚öîÔ∏è Event Limit Reached!\n\nYou have already played 10/10 event games today.\nCome back tomorrow to play more!');
            isEventMode = false;
            return;
        }
    }
    
    if (auth0Client) {
        try {
            const isAuthenticated = await auth0Client.isAuthenticated();
            if (isAuthenticated) {
                const user = await auth0Client.getUser();
                eventUser = user;
                showSecretCodeModal(user);
                return;
            }
        } catch (e) {
            console.log("Not authenticated yet");
        }
    }
    
    signInWithX(true);
}

async function checkEventPlayLimit(userId) {
  try {
    const eventPlaysRef = database.ref(`eventPlays/${userId}`);
    const playsSnapshot = await eventPlaysRef.once('value');
    const playsData = playsSnapshot.val();
    
    const today = new Date().toISOString().split('T')[0];
    let plays = 0;
    
    if (playsData && playsData.date === today) {
      plays = playsData.count || 0;
    }
    
    return {
      canPlay: plays < 10,
      playsToday: plays,
      remaining: Math.max(0, 10 - plays)
    };
  } catch (error) {
    console.error('Error checking play limit:', error);
    return { canPlay: true, playsToday: 0, remaining: 10 };
  }
}

async function incrementEventPlay(userId) {
  try {
    const today = new Date().toISOString().split('T')[0];
    const playRef = database.ref(`eventPlays/${userId}/${today}`);
    const snapshot = await playRef.once('value');
    const plays = snapshot.val() || 0;
    await playRef.set(plays + 1);
  } catch (error) {
    console.error('Error incrementing play count:', error);
  }
}

function showSecretCodeModal(user) {
    const modal = document.getElementById('secretCodeModal');
    const profilePic = document.getElementById('eventProfilePic');
    const handleDisplay = document.getElementById('eventHandleDisplay');
    const codeInput = document.getElementById('secretCodeInput');
    const errorDiv = document.getElementById('codeError');
    
    if (user.picture) {
        profilePic.src = user.picture;
        profilePic.style.display = 'block';
    }
    
    handleDisplay.textContent = `@${user.nickname || user.name || 'Player'}`;
    
    codeInput.value = '';
    errorDiv.style.display = 'none';
    
    modal.classList.add('active');
    codeInput.focus();
    
    codeInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
            verifySecretCode();
        }
    };
}

async function verifySecretCode() {
  const codeInput = document.getElementById('secretCodeInput');
  const errorDiv = document.getElementById('codeError');
  const enteredCode = codeInput.value.trim().toLowerCase();

  if (enteredCode === SECRETCODE) {
    if (!eventUser || !eventUser.sub) {
      errorDiv.textContent = 'Please sign in with X first';
      errorDiv.style.display = 'block';
      return;
    }

    const playLimit = await checkEventPlayLimit(eventUser.sub);
    
    if (!playLimit.canPlay) {
      errorDiv.textContent = `Daily limit reached! You've played ${playLimit.playsToday}/10 times today. Come back tomorrow!`;
      errorDiv.style.display = 'block';
      return;
    }

    errorDiv.style.display = 'none';
    document.getElementById('secretCodeModal').classList.remove('active');

    const xUserData = {
      xHandle: eventUser.nickname || eventUser.name || 'Player',
      xUserId: eventUser.sub,
      profilePic: eventUser.picture,
      name: eventUser.name
    };

    showPlayLimitNotification(playLimit.remaining);
    
    showUsernameModal(xUserData);
  } else {
    errorDiv.textContent = 'Incorrect code. Please try again.';
    errorDiv.style.display = 'block';
    codeInput.value = '';
    codeInput.focus();
    codeInput.style.animation = 'shake 0.5s';
    setTimeout(() => { codeInput.style.animation = ''; }, 500);
  }
}

function showPlayLimitNotification(remaining) {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(45deg, #FFD700, #FFAB52);
    color: #000;
    padding: 12px 25px;
    border-radius: 10px;
    font-weight: 700;
    z-index: 10000;
    font-family: 'Orbitron', monospace;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
  `;
  notification.textContent = `‚öîÔ∏è ${remaining} plays remaining today!`;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    if (notification.parentNode) notification.remove();
  }, 4000);
}

const originalSignInWithX = signInWithX || function() {};

async function signInWithX(forEvent = false) {
    if (forEvent) {
        isEventMode = true;
    }
    
    try {
        await auth0Client.loginWithPopup({
            authorizationParams: {
                connection: 'twitter',
                prompt: 'login'
            }
        });
        
        const user = await auth0Client.getUser();
        
        const xUserData = {
            xHandle: user.nickname || user.name || 'Player',
            xUserId: user.sub,
            profilePic: user.picture,
            displayName: user.name
        };
        
        if (isEventMode) {
            eventUser = user;
            showSecretCodeModal(user);
        } else {
            showUsernameModal(xUserData);
        }
    } catch (error) {
        console.error('Authentication failed:', error);
        alert('Failed to connect with X. Please try again.');
        isEventMode = false;
    }
}

function toggleEventLeaderboard() {
    const overlay = document.getElementById('eventLeaderboardOverlay');
    const panel = document.getElementById('eventLeaderboardPanel');
    
    overlay.classList.toggle('active');
    panel.classList.toggle('active');
    
    if (panel.classList.contains('active')) {
        loadEventLeaderboard();
    }
}

async function loadEventLeaderboard() {
    const list = document.getElementById('eventLeaderboardList');
    list.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Loading...</div>';
    
    try {
        const snapshot = await database.ref('eventLeaderboard')
            .orderByChild('score')
            .limitToLast(100)
            .once('value');
        
        const scores = [];
        snapshot.forEach((child) => {
            scores.push({
                id: child.key,
                ...child.val()
            });
        });
        
        scores.sort((a, b) => b.score - a.score);
        
        if (scores.length === 0) {
            list.innerHTML = `
                <div class="leaderboard-empty">
                    <div style="font-size: 3rem;">üèÜ</div>
                    <div style="margin-top: 10px;">No event scores yet. Be the first!</div>
                </div>
            `;
            return;
        }
        
        list.innerHTML = scores.map((entry, index) => `
            <div class="leaderboard-item ${index < 3 ? 'weekly-top' : ''}">
                <div class="leaderboard-rank">#${index + 1}</div>
                <div class="leaderboard-player">
                    <div class="leaderboard-player-name">${sanitizeInput(entry.username || 'Anonymous')}</div>
                </div>
                <div class="leaderboard-score">${entry.score.toLocaleString()}</div>
            </div>
        `).join('');
        
    } catch (error) {
        console.error('Failed to load event leaderboard:', error);
        list.innerHTML = '<div style="text-align: center; padding: 20px; color: #ff4444;">Failed to load leaderboard</div>';
    }
}

const originalSubmitScore = submitScore;

async function submitScore(scoreData) {
    if (isEventMode) {
        try {
            const eventScoreData = {
                ...scoreData,
                eventMode: true,
                timestamp: Date.now()
            };
            
            await database.ref('eventLeaderboard').push(eventScoreData);
            
            setTimeout(() => {
                toggleEventLeaderboard();
            }, 1000);
            
        } catch (error) {
            console.error('Failed to submit event score:', error);
        }
    } else {
        if (originalSubmitScore) {
            await originalSubmitScore(scoreData);
        }
    }
}

const originalGameOver = gameOver || function() {};

function gameOver() {
    if (typeof originalGameOver === 'function') {
        originalGameOver();
    }
    
    if (isEventMode) {
        const gameOverButtons = document.querySelector('.gameover-buttons');
        if (gameOverButtons && !document.getElementById('eventLeaderboardBtn')) {
            const eventLbBtn = document.createElement('button');
            eventLbBtn.id = 'eventLeaderboardBtn';
            eventLbBtn.className = 'share-btn';
            eventLbBtn.textContent = 'üèÜ EVENT LEADERBOARD';
            eventLbBtn.onclick = toggleEventLeaderboard;
            eventLbBtn.style.background = 'linear-gradient(45deg, #FFD700, #FFAB52)';
            gameOverButtons.appendChild(eventLbBtn);
        }
    }
}

</script>

<script type="module">
  import { consoleWalletPixelplex } from 'https://unpkg.com/@console-wallet/dapp-sdk@latest/dist/esm/index.js';
 
  window.consoleWalletPixelplex = consoleWalletPixelplex;
 
  let consoleWalletConnected = false;
  let consoleWalletAccount = null;

  const btn = document.getElementById('consoleWalletBtn');
  const btnText = document.getElementById('walletBtnText');
  const dropdown = document.getElementById('walletDropdown');

  function setWalletUI(connected) {
    consoleWalletConnected = connected;
    const signBtn = document.getElementById('signMessageBtn');
   
    if (connected) {
      btn.classList.add('connected');
      btnText.textContent = 'Wallet connected';
      if (signBtn) signBtn.style.display = 'flex';
    } else {
      btn.classList.remove('connected');
      btnText.textContent = 'Connect Console Wallet';
      dropdown.classList.remove('active');
      if (signBtn) signBtn.style.display = 'none';
    }
  }

  function showWalletNotInstalledModal() {
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 500px;">
        <div class="modal-title">üîå WALLET NOT DETECTED</div>
        <div style="margin-bottom: 30px;">
          <div class="rule-item">
            <div class="rule-desc" style="text-align: center;">
              Console Wallet extension is required to connect your wallet.
            </div>
          </div>
          <div class="rule-item" style="border-left-color: #ffab52;">
            <div class="rule-title" style="color: #ffab52;">üì• INSTALL NOW</div>
            <div class="rule-desc">
              Visit: <a href="https://consolewallet.io/" target="_blank"
              style="color: #c4d86f; text-decoration: underline;">consolewallet.io</a>
            </div>
          </div>
        </div>
        <button class="close-btn" onclick="this.closest('.modal').remove()">GOT IT! ‚öîÔ∏è</button>
      </div>
    `;
    document.body.appendChild(modal);
  }

  function showWalletErrorModal(message) {
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 500px;">
        <div class="modal-title" style="color: #ff4444;">‚ö†Ô∏è CONNECTION FAILED</div>
        <div class="rule-item" style="border-left-color: #ff4444;">
          <div class="rule-desc" style="text-align: center;">
            ${message}
          </div>
        </div>
        <button class="close-btn" onclick="this.closest('.modal').remove()">TRY AGAIN ‚öîÔ∏è</button>
      </div>
    `;
    document.body.appendChild(modal);
  }

  window.handleConsoleWallet = async function () {
    if (consoleWalletConnected) {
      dropdown.classList.toggle('active');
      return;
    }

    try {
      btnText.textContent = 'Connecting‚Ä¶';
     
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Extension timeout')), 1000)
      );
     
      try {
        const statusResult = await Promise.race([
          consoleWalletPixelplex.status(),
          timeoutPromise
        ]);
      } catch (checkError) {
        showWalletNotInstalledModal();
        btnText.textContent = 'Connect Console Wallet';
        return;
      }

      await consoleWalletPixelplex.connect({
        name: 'Canton Army Battle',
        icon: `${window.location.protocol}//${window.location.host}/cn-favicon-05%201-1.webp`,
      });
    } catch (e) {
      console.error('Connect error:', e);
      showWalletErrorModal('Failed to connect wallet. Please try again.');
      setWalletUI(false);
    }
  };

  window.disconnectWallet = async function () {
    setWalletUI(false);

    try {
      await consoleWalletPixelplex.disconnect();
    } catch (e) {
      console.error('Disconnect error', e);
    }
  };

  window.signBattleMessage = async function () {
  if (!consoleWalletConnected) {
    showWalletErrorModal('Please connect your Console Wallet first');
    return;
  }

  const signBtn = document.getElementById('signMessageBtn');
  const signBtnText = document.getElementById('signBtnText');
  const originalText = signBtnText.textContent;

  try {
    signBtnText.textContent = 'Check your wallet...';
    signBtn.disabled = true;

    const accounts = await consoleWalletPixelplex.getAccounts();
    if (!accounts || accounts.length === 0) throw new Error('No account found');
    
    const activeAccount = accounts[0];
    const walletAddress = activeAccount.partyId || activeAccount.party || activeAccount.address;

    const username = walletAddress.includes('::') 
      ? walletAddress.split('::')[0] 
      : walletAddress.substring(0, 10);

    const alreadySigned = await checkIfAlreadySigned(walletAddress);
    if (alreadySigned) {
      signBtnText.textContent = originalText;
      signBtn.disabled = false;
      showWalletErrorModal(`${username} has already signed Canton Army Battle! ‚öîÔ∏è`);
      return;
    }

    const message = "Canton Army x Console Wallet Event";
    const base64Message = btoa(message);

    const signRequest = {
      message: { base64: base64Message }
    };

    const signResult = await consoleWalletPixelplex.signMessage(signRequest);
    
    signBtnText.textContent = originalText;
    signBtn.disabled = false;

    if (!signResult) throw new Error('No signature received');

    let signature = signResult;
    if (typeof signResult !== 'string') {
      signature = signResult.signature || signResult.signedMessage || signResult.result || JSON.stringify(signResult);
    }

    await saveSignedUser(walletAddress, username, signature, message);
    showVerificationSuccessModal(message, walletAddress, username, signature);
    
    return true;

  } catch (error) {
    console.error('Sign Error:', error);
    signBtnText.textContent = 'Sign Message'; 
    signBtn.disabled = false;
    showWalletErrorModal(error.message || 'Wallet connection failed');
  }
};

async function checkIfAlreadySigned(walletAddress) {
  try {
    const safeKey = walletAddress.replace(/[.#$[\]:]/g, '_');
    const snapshot = await database.ref('signedUsers/' + safeKey).once('value');
    return snapshot.exists();
  } catch (error) {
    console.error('Error checking signature status:', error);
    return false;
  }
}

async function saveSignedUser(walletAddress, username, signature, message) {
  try {
    const safeKey = walletAddress.replace(/[.#$[\]:]/g, '_');
        
    const signedUserData = {
      walletAddress: walletAddress,
      signature: signature,
      message: message,
      signedAt: Date.now(),
      timestamp: new Date().toISOString(),
      verified: true
    };

    const signedUsersRef = database.ref('signedUsers/' + safeKey);
    await signedUsersRef.set(signedUserData);
    
    return true;
  } catch (error) {
    console.error('‚ùå Error saving to Firebase:', error);
    throw error;
  }
}

function showVerificationSuccessModal(originalMessage, walletAddress, username, signature) {
  const modal = document.createElement('div');
  modal.className = 'modal active';
  
  const shortWallet = walletAddress.length > 20 
    ? walletAddress.substring(0, 15) + '...' + walletAddress.substring(walletAddress.length - 8)
    : walletAddress;
  
  const shortSig = signature && signature.length > 50
    ? signature.substring(0, 25) + '...' + signature.substring(signature.length - 25)
    : signature;
  
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-title" style="color: #4ade80;">‚úÖ MESSAGE SIGNED</div>
      <div class="rule-item" style="border-left-color: #4ade80;">
        <div class="rule-title" style="color: #c4d86f;">üë§ WARRIOR</div>
        <div class="rule-desc" style="font-size: 1.2rem; font-weight: 700;">${username}</div>
      </div>
      <div class="rule-item" style="border-left-color: #c4d86f;">
        <div class="rule-title" style="color: #c4d86f;">üëõ CONSOLE WALLET</div>
        <div class="rule-desc" style="word-break: break-all; font-size: 0.75rem;" title="${walletAddress}">${shortWallet}</div>
      </div>
      <div class="rule-item" style="border-left-color: #4ade80;">
        <div class="rule-title" style="color: #c4d86f;">üìù MESSAGE</div>
        <div class="rule-desc" style="font-size: 0.85rem;">${originalMessage}</div>
      </div>
      <div class="rule-item" style="border-left-color: #ffab52;">
        <div class="rule-title" style="color: #ffab52;">‚úçÔ∏è SIGNATURE</div>
        <div class="rule-desc" style="word-break: break-all; font-size: 0.7rem;" title="${signature}">${shortSig}</div>
      </div>
      <div style="text-align: center; color: #4ade80; font-size: 0.9rem; margin-top: 15px; padding: 20px; background: rgba(74, 222, 128, 0.1); border-radius: 10px; border: 2px solid rgba(74, 222, 128, 0.3);">
        <div style="font-size: 2rem; margin-bottom: 10px;">üéâ</div>
        <strong>Welcome, ${username}!</strong><br>
        <span style="font-size: 0.85rem; color: #c4d86f; margin-top: 8px; display: block;">
          You signed the message in your Console Wallet<br>
          <span style="color: #4ade80;">‚ú® 100% FREE - No gas fees charged</span>
        </span>
      </div>
      <button class="close-btn" onclick="this.closest('.modal').remove()">CONTINUE ‚öîÔ∏è</button>
    </div>
  `;
  document.body.appendChild(modal);
}

  consoleWalletPixelplex.onConnectionStatusChanged(async (status) => {
    if (status === 'connected') {
      setWalletUI(true);
      try {
        const accounts = await consoleWalletPixelplex.getAccounts();
        consoleWalletAccount = accounts && accounts[0] ? accounts[0] : null;
      } catch (e) {
        console.log('Could not fetch accounts:', e);
      }
    } else if (status === 'disconnected') {
      setWalletUI(false);
      consoleWalletAccount = null;
    }
  });

  (async () => {
    try {
      const status = await consoleWalletPixelplex.status();
      if (status === 'connected') {
        setWalletUI(true);
        const accounts = await consoleWalletPixelplex.getAccounts();
        consoleWalletAccount = accounts && accounts[0] ? accounts[0] : null;
      } else {
        setWalletUI(false);
      }
    } catch (e) {
      setWalletUI(false);
    }
  })();

  document.addEventListener('click', function(event) {
    if (!dropdown) return;
    if (!btn.contains(event.target) && !dropdown.contains(event.target)) {
      dropdown.classList.remove('active');
    }
  });

</script>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyB23Rm_Tw0wpksk3VtuZ7X34CoA0TBKw80",
  authDomain: "canton-army-battle.firebaseapp.com",
  databaseURL: "https://canton-army-battle-default-rtdb.firebaseio.com",
  projectId: "canton-army-battle",
  storageBucket: "canton-army-battle.firebasestorage.app",
  messagingSenderId: "779055333066",
  appId: "1:779055333066:web:bef52a082fd4e387fbfe33"
};

if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
  self.FIREBASE_APPCHECK_DEBUG_TOKEN = true;
}

const app = firebase.initializeApp(firebaseConfig);
const database = firebase.database();

const appCheck = firebase.appCheck();
appCheck.activate(
  '6LcokSMsAAAAAIH7I8lMJ3xQt_VL_QMlHqC5qE2C',
  true
);

class RateLimiter {
  constructor(maxSubmissions = 20, windowMs = 3600000) {
    this.maxSubmissions = maxSubmissions;
    this.windowMs = windowMs;
  }

  async checkRateLimit(userId) {
    try {
      const rateLimitRef = database.ref(`rateLimits/${userId}`);
      const snapshot = await rateLimitRef.once('value');
      const data = snapshot.val();

      const now = Date.now();
      let submissions = [];

      if (data && data.submissions) {
        submissions = data.submissions.filter(timestamp => 
          now - timestamp < this.windowMs
        );
      }

      if (submissions.length >= this.maxSubmissions) {
        const oldestSubmission = Math.min(...submissions);
        const timeUntilReset = Math.ceil((this.windowMs - (now - oldestSubmission)) / 60000);
        return {
          allowed: false,
          remaining: 0,
          resetIn: timeUntilReset
        };
      }

      submissions.push(now);

      await rateLimitRef.set({
        submissions: submissions,
        lastSubmission: now
      });

      return {
        allowed: true,
        remaining: this.maxSubmissions - submissions.length,
        resetIn: 60
      };

    } catch (error) {
      console.error('Rate limit check failed:', error);
      return { allowed: true, remaining: this.maxSubmissions, resetIn: 60 };
    }
  }
}

const rateLimiter = new RateLimiter(20, 3600000);

async function submitScoreToFirebase(scoreData) {
  try {
    const userId = currentUser.xUserId || 'guest_' + Date.now();
    
    let username = currentUser.xHandle ? `@${currentUser.xHandle}` : currentUser.displayName;

    if (!username && currentUser.xUserId) {
      username = await getSavedUsername(currentUser.xUserId);
    }

    username = username || 'Guest';
    
    if (isEventMode) {
      // Check event play limit with daily reset
      const eventPlaysRef = database.ref(`eventPlays/${userId}`);
      const playsSnapshot = await eventPlaysRef.once('value');
      const playsData = playsSnapshot.val();
      
      let gamesPlayed = 0;
      const today = new Date().toISOString().split('T')[0];
      
      // If data exists, check if it's from today
      if (playsData && playsData.date === today) {
        gamesPlayed = playsData.count || 0;
      }
      // If different day or no data, start fresh at 0
      
      console.log('üìÖ Event games played today:', gamesPlayed, 'Date:', today);
      
      if (gamesPlayed >= 10) {
        showSubmissionError(`‚öîÔ∏è Event limit reached! You have played ${gamesPlayed}/10 event games today. Come back tomorrow!`);
        return false;
      }
      
      const existingScoreSnapshot = await database.ref('eventLeaderboard')
        .orderByChild('userId')
        .equalTo(userId)
        .once('value');
      
      let shouldSubmit = true;
      let existingKey = null;
      
      existingScoreSnapshot.forEach((child) => {
        const existingScore = child.val().score;
        if (scoreData.score <= existingScore) {
          shouldSubmit = false;
        } else {
          existingKey = child.key;
        }
      });
      
      if (!shouldSubmit) {
        showSubmissionSuccess('Score recorded! (Not your best)');
        
        await eventPlaysRef.set({
          count: gamesPlayed + 1,
          date: today
        });
        
        return true;
      }
      
      const eventScoreData = {
        userId: userId,
        username: sanitizeInput(username),
        xHandle: currentUser.xHandle || null,
        profilePic: currentUser.profilePic || null,
        score: scoreData.score,
        nodesDestroyed: scoreData.nodesDestroyed,
        nodesMissed: scoreData.nodesMissed,
        bestCombo: scoreData.bestCombo,
        eventMode: true,
        timestamp: Date.now()
      };
      
      if (existingKey) {
        await database.ref('eventLeaderboard/' + existingKey).set(eventScoreData);
        showSubmissionSuccess('NEW HIGH SCORE! üî•');
      } else {
        await database.ref('eventLeaderboard').push(eventScoreData);
        showSubmissionSuccess('Event score saved!');
      }
      
        await eventPlaysRef.set({
        count: gamesPlayed + 1,
        date: today
      });
      
      return true;
    }
    
    if (!currentSession.isValidSession()) {
      console.error('‚ùå Invalid game session');
      showSubmissionError('Invalid game session. Score not saved.');
      return false;
    }

    const sessionData = currentSession.getSessionData();

    const rateCheck = await rateLimiter.checkRateLimit(userId);
    if (!rateCheck.allowed) {
      showSubmissionError(`Rate limit exceeded! You can submit again in ${rateCheck.resetIn} minutes.`);
      return false;
    }

    const submission = {
      userId: userId,
      username: sanitizeInput(username),
      xHandle: currentUser.xHandle || null,
      profilePic: currentUser.profilePic || null,
      score: scoreData.score,
      nodesDestroyed: scoreData.nodesDestroyed,
      nodesMissed: scoreData.nodesMissed,
      bestCombo: scoreData.bestCombo,
      timestamp: Date.now(),
      duration: sessionData.duration,
      sessionId: sessionData.sessionId,
      flagged: false,
      checkpointCount: sessionData.checkpoints.length
    };

    await Promise.all([
      submitToAllTime(submission),
      submitToWeekly(submission)
    ]);

    showSubmissionSuccess(`Score saved! ${rateCheck.remaining} submissions remaining this hour.`);
    return true;

  } catch (error) {
    console.error('‚ùå Score submission failed:', error);
    showSubmissionError('Failed to save score. Please try again.');
    return false;
  }
}

function validateScoreData(scoreData, sessionData) {
  const suspicious = [];
  
  if (scoreData.score > 150000) {
    suspicious.push('score_too_high');
  }

  const duration = sessionData.duration / 1000;
  const scorePerSecond = scoreData.score / duration;
  if (scorePerSecond > 800) {
    suspicious.push('impossible_score_rate');
  }

  if (scoreData.bestCombo > 80) {
    suspicious.push('combo_too_high');
  }

  if (scoreData.nodesDestroyed > 250) {
    suspicious.push('too_many_nodes');
  }

  const avgScorePerNode = scoreData.score / Math.max(1, scoreData.nodesDestroyed);
  if (avgScorePerNode > 600 || avgScorePerNode < 5) {
    suspicious.push('invalid_score_ratio');
  }

  if (scoreData.score % 10000 === 0 && scoreData.score >= 50000) {
    suspicious.push('perfect_round_number');
  }

  if (duration < 20 || duration > 600) {
    return { valid: false, reason: 'invalid_duration', suspicious: true };
  }

  return {
    valid: true,
    suspicious: suspicious.length > 0,
    flags: suspicious
  };
}

async function submitToAllTime(submission) {
  const userScoreRef = database.ref(`leaderboard/alltime/${submission.userId}`);
  const snapshot = await userScoreRef.once('value');
  const existingScore = snapshot.val();

  if (!existingScore || submission.score > existingScore.score) {
    await userScoreRef.set(submission);
  }
}

async function submitToWeekly(submission) {
  const weekId = getWeekIdentifier();
  const userScoreRef = database.ref(`leaderboard/weekly/${weekId}/${submission.userId}`);
  const snapshot = await userScoreRef.once('value');
  const existingScore = snapshot.val();

  if (!existingScore || submission.score > existingScore.score) {
    await userScoreRef.set({
      ...submission,
      weekStart: getWeekStart()
    });
  }
}

function getWeekIdentifier(offset = 0) {
  const date = new Date();
  date.setDate(date.getDate() + (offset * 7));
  
  const year = date.getFullYear();
  const firstDayOfYear = new Date(year, 0, 1);
  const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
  const weekNumber = Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);
  
  return `${year}-W${weekNumber.toString().padStart(2, '0')}`;
}

function showSubmissionError(message) {
  const errorDiv = document.createElement('div');
  errorDiv.style.cssText = `
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #ff4444;
    color: white;
    padding: 15px 30px;
    border-radius: 10px;
    font-weight: 900;
    z-index: 10000;
    font-family: Orbitron, monospace;
    box-shadow: 0 0 20px rgba(255, 68, 68, 0.8);
  `;
  errorDiv.textContent = message;
  document.body.appendChild(errorDiv);
  
  setTimeout(() => {
    if (errorDiv.parentNode) errorDiv.remove();
  }, 5000);
}

function showSubmissionSuccess(message) {
  const successDiv = document.createElement('div');
  successDiv.style.cssText = `
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #c4d86f;
    color: #000;
    padding: 15px 30px;
    border-radius: 10px;
    font-weight: 900;
    z-index: 10000;
    font-family: Orbitron, monospace;
    box-shadow: 0 0 20px rgba(196, 216, 111, 0.8);
  `;
  successDiv.textContent = message;
  document.body.appendChild(successDiv);
  
  setTimeout(() => {
    if (successDiv.parentNode) successDiv.remove();
  }, 4000);
}


</script>

</body>
</html>
